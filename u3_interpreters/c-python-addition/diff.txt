diff --git a/Doc/data/python3.11.abi b/Doc/data/python3.11.abi
index 14ffe9cab2..d85bb131bc 100644
--- a/Doc/data/python3.11.abi
+++ b/Doc/data/python3.11.abi
@@ -11755,6 +11755,7 @@
       <enumerator name='Pass_kind' value='25'/>
       <enumerator name='Break_kind' value='26'/>
       <enumerator name='Continue_kind' value='27'/>
+      <enumerator name='Until_kind' value='28'/>
     </enum-decl>
     <union-decl name='__anonymous_union__' size-in-bits='384' is-anonymous='yes' visibility='default' filepath='./Include/internal/pycore_ast.h' line='187' column='1' id='type-id-614'>
       <data-member access='private'>
diff --git a/Grammar/python.gram b/Grammar/python.gram
index bae8bc3224..1161bc61b3 100644
--- a/Grammar/python.gram
+++ b/Grammar/python.gram
@@ -133,6 +133,7 @@ compound_stmt[stmt_ty]:
     | &('for' | ASYNC) for_stmt
     | &'try' try_stmt
     | &'while' while_stmt
+    | &'until' until_stmt
     | match_stmt
 
 # SIMPLE STATEMENTS
@@ -374,6 +375,13 @@ while_stmt[stmt_ty]:
     | invalid_while_stmt
     | 'while' a=named_expression ':' b=block c=[else_block] { _PyAST_While(a, b, c, EXTRA) }
 
+# Until statement
+# ---------------
+
+until_stmt[stmt_ty]:
+    | invalid_until_stmt
+    | 'until' a=named_expression ':' b=block c=[else_block] { _PyAST_Until(a, b, c, EXTRA) }
+
 # For statement
 # -------------
 
@@ -1300,6 +1308,10 @@ invalid_while_stmt:
     | 'while' named_expression NEWLINE { RAISE_SYNTAX_ERROR("expected ':'") }
     | a='while' named_expression ':' NEWLINE !INDENT {
         RAISE_INDENTATION_ERROR("expected an indented block after 'while' statement on line %d", a->lineno) }
+invalid_until_stmt:
+    | 'until' named_expression NEWLINE { RAISE_SYNTAX_ERROR("expected ':'") }
+    | a='until' named_expression ':' NEWLINE !INDENT {
+        RAISE_INDENTATION_ERROR("expected an indented block after 'until' statement on line %d", a->lineno) }
 invalid_for_stmt:
     | [ASYNC] 'for' star_targets 'in' star_expressions NEWLINE { RAISE_SYNTAX_ERROR("expected ':'") }
     | [ASYNC] a='for' star_targets 'in' star_expressions ':' NEWLINE !INDENT {
diff --git a/Include/internal/pycore_ast.h b/Include/internal/pycore_ast.h
index 36277efe9c..ce4bf48bf2 100644
--- a/Include/internal/pycore_ast.h
+++ b/Include/internal/pycore_ast.h
@@ -177,11 +177,12 @@ struct _mod {
 enum _stmt_kind {FunctionDef_kind=1, AsyncFunctionDef_kind=2, ClassDef_kind=3,
                   Return_kind=4, Delete_kind=5, Assign_kind=6,
                   AugAssign_kind=7, AnnAssign_kind=8, For_kind=9,
-                  AsyncFor_kind=10, While_kind=11, If_kind=12, With_kind=13,
-                  AsyncWith_kind=14, Match_kind=15, Raise_kind=16, Try_kind=17,
-                  TryStar_kind=18, Assert_kind=19, Import_kind=20,
-                  ImportFrom_kind=21, Global_kind=22, Nonlocal_kind=23,
-                  Expr_kind=24, Pass_kind=25, Break_kind=26, Continue_kind=27};
+                  AsyncFor_kind=10, While_kind=11, Until_kind=12, If_kind=13,
+                  With_kind=14, AsyncWith_kind=15, Match_kind=16,
+                  Raise_kind=17, Try_kind=18, TryStar_kind=19, Assert_kind=20,
+                  Import_kind=21, ImportFrom_kind=22, Global_kind=23,
+                  Nonlocal_kind=24, Expr_kind=25, Pass_kind=26, Break_kind=27,
+                  Continue_kind=28};
 struct _stmt {
     enum _stmt_kind kind;
     union {
@@ -260,6 +261,12 @@ struct _stmt {
             asdl_stmt_seq *orelse;
         } While;
 
+        struct {
+            expr_ty test;
+            asdl_stmt_seq *body;
+            asdl_stmt_seq *orelse;
+        } Until;
+
         struct {
             expr_ty test;
             asdl_stmt_seq *body;
@@ -677,6 +684,9 @@ stmt_ty _PyAST_AsyncFor(expr_ty target, expr_ty iter, asdl_stmt_seq * body,
 stmt_ty _PyAST_While(expr_ty test, asdl_stmt_seq * body, asdl_stmt_seq *
                      orelse, int lineno, int col_offset, int end_lineno, int
                      end_col_offset, PyArena *arena);
+stmt_ty _PyAST_Until(expr_ty test, asdl_stmt_seq * body, asdl_stmt_seq *
+                     orelse, int lineno, int col_offset, int end_lineno, int
+                     end_col_offset, PyArena *arena);
 stmt_ty _PyAST_If(expr_ty test, asdl_stmt_seq * body, asdl_stmt_seq * orelse,
                   int lineno, int col_offset, int end_lineno, int
                   end_col_offset, PyArena *arena);
diff --git a/Include/internal/pycore_ast_state.h b/Include/internal/pycore_ast_state.h
index f15b4905ee..a577aad32d 100644
--- a/Include/internal/pycore_ast_state.h
+++ b/Include/internal/pycore_ast_state.h
@@ -143,6 +143,7 @@ struct ast_state {
     PyObject *USub_singleton;
     PyObject *USub_type;
     PyObject *UnaryOp_type;
+    PyObject *Until_type;
     PyObject *While_type;
     PyObject *With_type;
     PyObject *YieldFrom_type;
diff --git a/Parser/Python.asdl b/Parser/Python.asdl
index e9423a7c98..50194cb2da 100644
--- a/Parser/Python.asdl
+++ b/Parser/Python.asdl
@@ -32,6 +32,7 @@ module Python
           | For(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)
           | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)
           | While(expr test, stmt* body, stmt* orelse)
+          | Until(expr test, stmt* body, stmt* orelse)
           | If(expr test, stmt* body, stmt* orelse)
           | With(withitem* items, stmt* body, string? type_comment)
           | AsyncWith(withitem* items, stmt* body, string? type_comment)
diff --git a/Parser/parser.c b/Parser/parser.c
index b2c0cfe3c2..6b0c3cd0a9 100644
--- a/Parser/parser.c
+++ b/Parser/parser.c
@@ -17,57 +17,58 @@ static KeywordToken *reserved_keywords[] = {
     (KeywordToken[]) {{NULL, -1}},
     (KeywordToken[]) {{NULL, -1}},
     (KeywordToken[]) {
-        {"if", 639},
-        {"as", 637},
-        {"in", 648},
-        {"or", 574},
-        {"is", 582},
+        {"if", 641},
+        {"as", 639},
+        {"in", 652},
+        {"or", 576},
+        {"is", 584},
         {NULL, -1},
     },
     (KeywordToken[]) {
-        {"del", 603},
-        {"def", 649},
-        {"for", 647},
-        {"try", 621},
-        {"and", 575},
-        {"not", 581},
+        {"del", 605},
+        {"def", 653},
+        {"for", 651},
+        {"try", 623},
+        {"and", 577},
+        {"not", 583},
         {NULL, -1},
     },
     (KeywordToken[]) {
-        {"from", 572},
+        {"from", 574},
         {"pass", 504},
-        {"with", 612},
-        {"elif", 641},
-        {"else", 642},
-        {"None", 601},
-        {"True", 600},
+        {"with", 614},
+        {"elif", 643},
+        {"else", 644},
+        {"None", 603},
+        {"True", 602},
         {NULL, -1},
     },
     (KeywordToken[]) {
-        {"raise", 522},
-        {"yield", 573},
+        {"raise", 523},
+        {"yield", 575},
         {"break", 508},
-        {"class", 651},
-        {"while", 644},
-        {"False", 602},
+        {"class", 655},
+        {"while", 646},
+        {"until", 648},
+        {"False", 604},
         {NULL, -1},
     },
     (KeywordToken[]) {
-        {"return", 519},
-        {"import", 531},
-        {"assert", 526},
-        {"global", 523},
-        {"except", 634},
-        {"lambda", 586},
+        {"return", 520},
+        {"import", 532},
+        {"assert", 527},
+        {"global", 524},
+        {"except", 636},
+        {"lambda", 588},
         {NULL, -1},
     },
     (KeywordToken[]) {
-        {"finally", 630},
+        {"finally", 632},
         {NULL, -1},
     },
     (KeywordToken[]) {
         {"continue", 509},
-        {"nonlocal", 524},
+        {"nonlocal", 525},
         {NULL, -1},
     },
 };
@@ -132,429 +133,431 @@ static char *soft_keywords[] = {
 #define elif_stmt_type 1052
 #define else_block_type 1053
 #define while_stmt_type 1054
-#define for_stmt_type 1055
-#define with_stmt_type 1056
-#define with_item_type 1057
-#define try_stmt_type 1058
-#define except_block_type 1059
-#define except_star_block_type 1060
-#define finally_block_type 1061
-#define match_stmt_type 1062
-#define subject_expr_type 1063
-#define case_block_type 1064
-#define guard_type 1065
-#define patterns_type 1066
-#define pattern_type 1067
-#define as_pattern_type 1068
-#define or_pattern_type 1069
-#define closed_pattern_type 1070
-#define literal_pattern_type 1071
-#define literal_expr_type 1072
-#define complex_number_type 1073
-#define signed_number_type 1074
-#define signed_real_number_type 1075
-#define real_number_type 1076
-#define imaginary_number_type 1077
-#define capture_pattern_type 1078
-#define pattern_capture_target_type 1079
-#define wildcard_pattern_type 1080
-#define value_pattern_type 1081
-#define attr_type 1082  // Left-recursive
-#define name_or_attr_type 1083  // Left-recursive
-#define group_pattern_type 1084
-#define sequence_pattern_type 1085
-#define open_sequence_pattern_type 1086
-#define maybe_sequence_pattern_type 1087
-#define maybe_star_pattern_type 1088
-#define star_pattern_type 1089
-#define mapping_pattern_type 1090
-#define items_pattern_type 1091
-#define key_value_pattern_type 1092
-#define double_star_pattern_type 1093
-#define class_pattern_type 1094
-#define positional_patterns_type 1095
-#define keyword_patterns_type 1096
-#define keyword_pattern_type 1097
-#define expressions_type 1098
-#define expression_type 1099
-#define yield_expr_type 1100
-#define star_expressions_type 1101
-#define star_expression_type 1102
-#define star_named_expressions_type 1103
-#define star_named_expression_type 1104
-#define assignment_expression_type 1105
-#define named_expression_type 1106
-#define disjunction_type 1107
-#define conjunction_type 1108
-#define inversion_type 1109
-#define comparison_type 1110
-#define compare_op_bitwise_or_pair_type 1111
-#define eq_bitwise_or_type 1112
-#define noteq_bitwise_or_type 1113
-#define lte_bitwise_or_type 1114
-#define lt_bitwise_or_type 1115
-#define gte_bitwise_or_type 1116
-#define gt_bitwise_or_type 1117
-#define notin_bitwise_or_type 1118
-#define in_bitwise_or_type 1119
-#define isnot_bitwise_or_type 1120
-#define is_bitwise_or_type 1121
-#define bitwise_or_type 1122  // Left-recursive
-#define bitwise_xor_type 1123  // Left-recursive
-#define bitwise_and_type 1124  // Left-recursive
-#define shift_expr_type 1125  // Left-recursive
-#define sum_type 1126  // Left-recursive
-#define term_type 1127  // Left-recursive
-#define factor_type 1128
-#define power_type 1129
-#define await_primary_type 1130
-#define primary_type 1131  // Left-recursive
-#define slices_type 1132
-#define slice_type 1133
-#define atom_type 1134
-#define group_type 1135
-#define lambdef_type 1136
-#define lambda_params_type 1137
-#define lambda_parameters_type 1138
-#define lambda_slash_no_default_type 1139
-#define lambda_slash_with_default_type 1140
-#define lambda_star_etc_type 1141
-#define lambda_kwds_type 1142
-#define lambda_param_no_default_type 1143
-#define lambda_param_with_default_type 1144
-#define lambda_param_maybe_default_type 1145
-#define lambda_param_type 1146
-#define strings_type 1147
-#define list_type 1148
-#define tuple_type 1149
-#define set_type 1150
-#define dict_type 1151
-#define double_starred_kvpairs_type 1152
-#define double_starred_kvpair_type 1153
-#define kvpair_type 1154
-#define for_if_clauses_type 1155
-#define for_if_clause_type 1156
-#define listcomp_type 1157
-#define setcomp_type 1158
-#define genexp_type 1159
-#define dictcomp_type 1160
-#define arguments_type 1161
-#define args_type 1162
-#define kwargs_type 1163
-#define starred_expression_type 1164
-#define kwarg_or_starred_type 1165
-#define kwarg_or_double_starred_type 1166
-#define star_targets_type 1167
-#define star_targets_list_seq_type 1168
-#define star_targets_tuple_seq_type 1169
-#define star_target_type 1170
-#define target_with_star_atom_type 1171
-#define star_atom_type 1172
-#define single_target_type 1173
-#define single_subscript_attribute_target_type 1174
-#define t_primary_type 1175  // Left-recursive
-#define t_lookahead_type 1176
-#define del_targets_type 1177
-#define del_target_type 1178
-#define del_t_atom_type 1179
-#define type_expressions_type 1180
-#define func_type_comment_type 1181
-#define invalid_arguments_type 1182
-#define invalid_kwarg_type 1183
-#define expression_without_invalid_type 1184
-#define invalid_legacy_expression_type 1185
-#define invalid_expression_type 1186
-#define invalid_named_expression_type 1187
-#define invalid_assignment_type 1188
-#define invalid_ann_assign_target_type 1189
-#define invalid_del_stmt_type 1190
-#define invalid_block_type 1191
-#define invalid_comprehension_type 1192
-#define invalid_dict_comprehension_type 1193
-#define invalid_parameters_type 1194
-#define invalid_default_type 1195
-#define invalid_star_etc_type 1196
-#define invalid_kwds_type 1197
-#define invalid_parameters_helper_type 1198
-#define invalid_lambda_parameters_type 1199
-#define invalid_lambda_parameters_helper_type 1200
-#define invalid_lambda_star_etc_type 1201
-#define invalid_lambda_kwds_type 1202
-#define invalid_double_type_comments_type 1203
-#define invalid_with_item_type 1204
-#define invalid_for_target_type 1205
-#define invalid_group_type 1206
-#define invalid_import_from_targets_type 1207
-#define invalid_with_stmt_type 1208
-#define invalid_with_stmt_indent_type 1209
-#define invalid_try_stmt_type 1210
-#define invalid_except_stmt_type 1211
-#define invalid_finally_stmt_type 1212
-#define invalid_except_stmt_indent_type 1213
-#define invalid_except_star_stmt_indent_type 1214
-#define invalid_match_stmt_type 1215
-#define invalid_case_block_type 1216
-#define invalid_as_pattern_type 1217
-#define invalid_class_pattern_type 1218
-#define invalid_class_argument_pattern_type 1219
-#define invalid_if_stmt_type 1220
-#define invalid_elif_stmt_type 1221
-#define invalid_else_stmt_type 1222
-#define invalid_while_stmt_type 1223
-#define invalid_for_stmt_type 1224
-#define invalid_def_raw_type 1225
-#define invalid_class_def_raw_type 1226
-#define invalid_double_starred_kvpairs_type 1227
-#define invalid_kvpair_type 1228
-#define _loop0_1_type 1229
-#define _loop0_2_type 1230
-#define _loop1_3_type 1231
-#define _loop0_5_type 1232
-#define _gather_4_type 1233
-#define _tmp_6_type 1234
-#define _tmp_7_type 1235
-#define _tmp_8_type 1236
-#define _tmp_9_type 1237
-#define _tmp_10_type 1238
-#define _tmp_11_type 1239
-#define _tmp_12_type 1240
-#define _tmp_13_type 1241
-#define _loop1_14_type 1242
-#define _tmp_15_type 1243
-#define _tmp_16_type 1244
-#define _tmp_17_type 1245
-#define _loop0_19_type 1246
-#define _gather_18_type 1247
-#define _loop0_21_type 1248
-#define _gather_20_type 1249
-#define _tmp_22_type 1250
-#define _tmp_23_type 1251
-#define _loop0_24_type 1252
-#define _loop1_25_type 1253
-#define _loop0_27_type 1254
-#define _gather_26_type 1255
-#define _tmp_28_type 1256
-#define _loop0_30_type 1257
-#define _gather_29_type 1258
-#define _tmp_31_type 1259
-#define _loop1_32_type 1260
-#define _tmp_33_type 1261
-#define _tmp_34_type 1262
-#define _tmp_35_type 1263
-#define _loop0_36_type 1264
-#define _loop0_37_type 1265
-#define _loop0_38_type 1266
-#define _loop1_39_type 1267
-#define _loop0_40_type 1268
-#define _loop1_41_type 1269
-#define _loop1_42_type 1270
-#define _loop1_43_type 1271
-#define _loop0_44_type 1272
-#define _loop1_45_type 1273
-#define _loop0_46_type 1274
-#define _loop1_47_type 1275
-#define _loop0_48_type 1276
-#define _loop0_49_type 1277
-#define _loop1_50_type 1278
-#define _loop0_52_type 1279
-#define _gather_51_type 1280
-#define _loop0_54_type 1281
-#define _gather_53_type 1282
-#define _loop0_56_type 1283
-#define _gather_55_type 1284
-#define _loop0_58_type 1285
-#define _gather_57_type 1286
-#define _tmp_59_type 1287
-#define _loop1_60_type 1288
-#define _loop1_61_type 1289
-#define _tmp_62_type 1290
-#define _tmp_63_type 1291
-#define _loop1_64_type 1292
-#define _loop0_66_type 1293
-#define _gather_65_type 1294
-#define _tmp_67_type 1295
-#define _tmp_68_type 1296
-#define _tmp_69_type 1297
-#define _tmp_70_type 1298
-#define _loop0_72_type 1299
-#define _gather_71_type 1300
-#define _loop0_74_type 1301
-#define _gather_73_type 1302
-#define _tmp_75_type 1303
-#define _loop0_77_type 1304
-#define _gather_76_type 1305
-#define _loop0_79_type 1306
-#define _gather_78_type 1307
-#define _loop1_80_type 1308
-#define _loop1_81_type 1309
-#define _loop0_83_type 1310
-#define _gather_82_type 1311
-#define _loop1_84_type 1312
-#define _loop1_85_type 1313
-#define _loop1_86_type 1314
-#define _tmp_87_type 1315
-#define _loop0_89_type 1316
-#define _gather_88_type 1317
-#define _tmp_90_type 1318
-#define _tmp_91_type 1319
-#define _tmp_92_type 1320
-#define _tmp_93_type 1321
-#define _tmp_94_type 1322
-#define _loop0_95_type 1323
-#define _loop0_96_type 1324
-#define _loop0_97_type 1325
-#define _loop1_98_type 1326
-#define _loop0_99_type 1327
-#define _loop1_100_type 1328
-#define _loop1_101_type 1329
-#define _loop1_102_type 1330
-#define _loop0_103_type 1331
-#define _loop1_104_type 1332
-#define _loop0_105_type 1333
-#define _loop1_106_type 1334
-#define _loop0_107_type 1335
-#define _loop1_108_type 1336
-#define _loop1_109_type 1337
-#define _tmp_110_type 1338
-#define _loop0_112_type 1339
-#define _gather_111_type 1340
-#define _loop1_113_type 1341
-#define _loop0_114_type 1342
-#define _loop0_115_type 1343
-#define _tmp_116_type 1344
-#define _loop0_118_type 1345
-#define _gather_117_type 1346
-#define _tmp_119_type 1347
-#define _loop0_121_type 1348
-#define _gather_120_type 1349
-#define _loop0_123_type 1350
-#define _gather_122_type 1351
-#define _loop0_125_type 1352
-#define _gather_124_type 1353
-#define _loop0_127_type 1354
-#define _gather_126_type 1355
-#define _loop0_128_type 1356
-#define _loop0_130_type 1357
-#define _gather_129_type 1358
-#define _loop1_131_type 1359
-#define _tmp_132_type 1360
-#define _loop0_134_type 1361
-#define _gather_133_type 1362
-#define _loop0_136_type 1363
-#define _gather_135_type 1364
-#define _loop0_138_type 1365
-#define _gather_137_type 1366
-#define _loop0_140_type 1367
-#define _gather_139_type 1368
-#define _loop0_142_type 1369
-#define _gather_141_type 1370
-#define _tmp_143_type 1371
-#define _tmp_144_type 1372
-#define _tmp_145_type 1373
-#define _tmp_146_type 1374
-#define _tmp_147_type 1375
-#define _tmp_148_type 1376
-#define _tmp_149_type 1377
-#define _tmp_150_type 1378
-#define _tmp_151_type 1379
-#define _loop0_152_type 1380
-#define _loop0_153_type 1381
-#define _loop0_154_type 1382
-#define _tmp_155_type 1383
-#define _tmp_156_type 1384
-#define _tmp_157_type 1385
-#define _tmp_158_type 1386
-#define _loop0_159_type 1387
-#define _loop0_160_type 1388
-#define _loop1_161_type 1389
-#define _tmp_162_type 1390
-#define _loop0_163_type 1391
-#define _tmp_164_type 1392
-#define _loop0_165_type 1393
-#define _tmp_166_type 1394
-#define _loop0_167_type 1395
-#define _loop1_168_type 1396
-#define _tmp_169_type 1397
-#define _tmp_170_type 1398
-#define _tmp_171_type 1399
-#define _loop0_172_type 1400
-#define _tmp_173_type 1401
-#define _tmp_174_type 1402
-#define _loop1_175_type 1403
-#define _loop0_176_type 1404
-#define _loop0_177_type 1405
-#define _loop0_179_type 1406
-#define _gather_178_type 1407
-#define _tmp_180_type 1408
-#define _loop0_181_type 1409
-#define _tmp_182_type 1410
-#define _loop0_183_type 1411
-#define _tmp_184_type 1412
-#define _loop0_185_type 1413
-#define _loop1_186_type 1414
-#define _loop1_187_type 1415
-#define _tmp_188_type 1416
-#define _tmp_189_type 1417
-#define _loop0_190_type 1418
-#define _tmp_191_type 1419
-#define _tmp_192_type 1420
-#define _tmp_193_type 1421
-#define _loop0_195_type 1422
-#define _gather_194_type 1423
-#define _loop0_197_type 1424
-#define _gather_196_type 1425
-#define _loop0_199_type 1426
-#define _gather_198_type 1427
-#define _loop0_201_type 1428
-#define _gather_200_type 1429
-#define _tmp_202_type 1430
-#define _loop0_203_type 1431
-#define _loop1_204_type 1432
-#define _tmp_205_type 1433
-#define _loop0_206_type 1434
-#define _loop1_207_type 1435
-#define _tmp_208_type 1436
-#define _tmp_209_type 1437
-#define _tmp_210_type 1438
-#define _tmp_211_type 1439
-#define _tmp_212_type 1440
-#define _tmp_213_type 1441
-#define _tmp_214_type 1442
-#define _tmp_215_type 1443
-#define _tmp_216_type 1444
-#define _tmp_217_type 1445
-#define _loop0_219_type 1446
-#define _gather_218_type 1447
-#define _tmp_220_type 1448
-#define _tmp_221_type 1449
-#define _tmp_222_type 1450
-#define _tmp_223_type 1451
-#define _tmp_224_type 1452
-#define _tmp_225_type 1453
-#define _tmp_226_type 1454
-#define _tmp_227_type 1455
-#define _tmp_228_type 1456
-#define _tmp_229_type 1457
-#define _tmp_230_type 1458
-#define _tmp_231_type 1459
-#define _tmp_232_type 1460
-#define _tmp_233_type 1461
-#define _tmp_234_type 1462
-#define _tmp_235_type 1463
-#define _tmp_236_type 1464
-#define _tmp_237_type 1465
-#define _tmp_238_type 1466
-#define _tmp_239_type 1467
-#define _tmp_240_type 1468
-#define _tmp_241_type 1469
-#define _tmp_242_type 1470
-#define _tmp_243_type 1471
-#define _tmp_244_type 1472
-#define _tmp_245_type 1473
-#define _tmp_246_type 1474
-#define _tmp_247_type 1475
-#define _tmp_248_type 1476
-#define _tmp_249_type 1477
+#define until_stmt_type 1055
+#define for_stmt_type 1056
+#define with_stmt_type 1057
+#define with_item_type 1058
+#define try_stmt_type 1059
+#define except_block_type 1060
+#define except_star_block_type 1061
+#define finally_block_type 1062
+#define match_stmt_type 1063
+#define subject_expr_type 1064
+#define case_block_type 1065
+#define guard_type 1066
+#define patterns_type 1067
+#define pattern_type 1068
+#define as_pattern_type 1069
+#define or_pattern_type 1070
+#define closed_pattern_type 1071
+#define literal_pattern_type 1072
+#define literal_expr_type 1073
+#define complex_number_type 1074
+#define signed_number_type 1075
+#define signed_real_number_type 1076
+#define real_number_type 1077
+#define imaginary_number_type 1078
+#define capture_pattern_type 1079
+#define pattern_capture_target_type 1080
+#define wildcard_pattern_type 1081
+#define value_pattern_type 1082
+#define attr_type 1083  // Left-recursive
+#define name_or_attr_type 1084  // Left-recursive
+#define group_pattern_type 1085
+#define sequence_pattern_type 1086
+#define open_sequence_pattern_type 1087
+#define maybe_sequence_pattern_type 1088
+#define maybe_star_pattern_type 1089
+#define star_pattern_type 1090
+#define mapping_pattern_type 1091
+#define items_pattern_type 1092
+#define key_value_pattern_type 1093
+#define double_star_pattern_type 1094
+#define class_pattern_type 1095
+#define positional_patterns_type 1096
+#define keyword_patterns_type 1097
+#define keyword_pattern_type 1098
+#define expressions_type 1099
+#define expression_type 1100
+#define yield_expr_type 1101
+#define star_expressions_type 1102
+#define star_expression_type 1103
+#define star_named_expressions_type 1104
+#define star_named_expression_type 1105
+#define assignment_expression_type 1106
+#define named_expression_type 1107
+#define disjunction_type 1108
+#define conjunction_type 1109
+#define inversion_type 1110
+#define comparison_type 1111
+#define compare_op_bitwise_or_pair_type 1112
+#define eq_bitwise_or_type 1113
+#define noteq_bitwise_or_type 1114
+#define lte_bitwise_or_type 1115
+#define lt_bitwise_or_type 1116
+#define gte_bitwise_or_type 1117
+#define gt_bitwise_or_type 1118
+#define notin_bitwise_or_type 1119
+#define in_bitwise_or_type 1120
+#define isnot_bitwise_or_type 1121
+#define is_bitwise_or_type 1122
+#define bitwise_or_type 1123  // Left-recursive
+#define bitwise_xor_type 1124  // Left-recursive
+#define bitwise_and_type 1125  // Left-recursive
+#define shift_expr_type 1126  // Left-recursive
+#define sum_type 1127  // Left-recursive
+#define term_type 1128  // Left-recursive
+#define factor_type 1129
+#define power_type 1130
+#define await_primary_type 1131
+#define primary_type 1132  // Left-recursive
+#define slices_type 1133
+#define slice_type 1134
+#define atom_type 1135
+#define group_type 1136
+#define lambdef_type 1137
+#define lambda_params_type 1138
+#define lambda_parameters_type 1139
+#define lambda_slash_no_default_type 1140
+#define lambda_slash_with_default_type 1141
+#define lambda_star_etc_type 1142
+#define lambda_kwds_type 1143
+#define lambda_param_no_default_type 1144
+#define lambda_param_with_default_type 1145
+#define lambda_param_maybe_default_type 1146
+#define lambda_param_type 1147
+#define strings_type 1148
+#define list_type 1149
+#define tuple_type 1150
+#define set_type 1151
+#define dict_type 1152
+#define double_starred_kvpairs_type 1153
+#define double_starred_kvpair_type 1154
+#define kvpair_type 1155
+#define for_if_clauses_type 1156
+#define for_if_clause_type 1157
+#define listcomp_type 1158
+#define setcomp_type 1159
+#define genexp_type 1160
+#define dictcomp_type 1161
+#define arguments_type 1162
+#define args_type 1163
+#define kwargs_type 1164
+#define starred_expression_type 1165
+#define kwarg_or_starred_type 1166
+#define kwarg_or_double_starred_type 1167
+#define star_targets_type 1168
+#define star_targets_list_seq_type 1169
+#define star_targets_tuple_seq_type 1170
+#define star_target_type 1171
+#define target_with_star_atom_type 1172
+#define star_atom_type 1173
+#define single_target_type 1174
+#define single_subscript_attribute_target_type 1175
+#define t_primary_type 1176  // Left-recursive
+#define t_lookahead_type 1177
+#define del_targets_type 1178
+#define del_target_type 1179
+#define del_t_atom_type 1180
+#define type_expressions_type 1181
+#define func_type_comment_type 1182
+#define invalid_arguments_type 1183
+#define invalid_kwarg_type 1184
+#define expression_without_invalid_type 1185
+#define invalid_legacy_expression_type 1186
+#define invalid_expression_type 1187
+#define invalid_named_expression_type 1188
+#define invalid_assignment_type 1189
+#define invalid_ann_assign_target_type 1190
+#define invalid_del_stmt_type 1191
+#define invalid_block_type 1192
+#define invalid_comprehension_type 1193
+#define invalid_dict_comprehension_type 1194
+#define invalid_parameters_type 1195
+#define invalid_default_type 1196
+#define invalid_star_etc_type 1197
+#define invalid_kwds_type 1198
+#define invalid_parameters_helper_type 1199
+#define invalid_lambda_parameters_type 1200
+#define invalid_lambda_parameters_helper_type 1201
+#define invalid_lambda_star_etc_type 1202
+#define invalid_lambda_kwds_type 1203
+#define invalid_double_type_comments_type 1204
+#define invalid_with_item_type 1205
+#define invalid_for_target_type 1206
+#define invalid_group_type 1207
+#define invalid_import_from_targets_type 1208
+#define invalid_with_stmt_type 1209
+#define invalid_with_stmt_indent_type 1210
+#define invalid_try_stmt_type 1211
+#define invalid_except_stmt_type 1212
+#define invalid_finally_stmt_type 1213
+#define invalid_except_stmt_indent_type 1214
+#define invalid_except_star_stmt_indent_type 1215
+#define invalid_match_stmt_type 1216
+#define invalid_case_block_type 1217
+#define invalid_as_pattern_type 1218
+#define invalid_class_pattern_type 1219
+#define invalid_class_argument_pattern_type 1220
+#define invalid_if_stmt_type 1221
+#define invalid_elif_stmt_type 1222
+#define invalid_else_stmt_type 1223
+#define invalid_while_stmt_type 1224
+#define invalid_until_stmt_type 1225
+#define invalid_for_stmt_type 1226
+#define invalid_def_raw_type 1227
+#define invalid_class_def_raw_type 1228
+#define invalid_double_starred_kvpairs_type 1229
+#define invalid_kvpair_type 1230
+#define _loop0_1_type 1231
+#define _loop0_2_type 1232
+#define _loop1_3_type 1233
+#define _loop0_5_type 1234
+#define _gather_4_type 1235
+#define _tmp_6_type 1236
+#define _tmp_7_type 1237
+#define _tmp_8_type 1238
+#define _tmp_9_type 1239
+#define _tmp_10_type 1240
+#define _tmp_11_type 1241
+#define _tmp_12_type 1242
+#define _tmp_13_type 1243
+#define _loop1_14_type 1244
+#define _tmp_15_type 1245
+#define _tmp_16_type 1246
+#define _tmp_17_type 1247
+#define _loop0_19_type 1248
+#define _gather_18_type 1249
+#define _loop0_21_type 1250
+#define _gather_20_type 1251
+#define _tmp_22_type 1252
+#define _tmp_23_type 1253
+#define _loop0_24_type 1254
+#define _loop1_25_type 1255
+#define _loop0_27_type 1256
+#define _gather_26_type 1257
+#define _tmp_28_type 1258
+#define _loop0_30_type 1259
+#define _gather_29_type 1260
+#define _tmp_31_type 1261
+#define _loop1_32_type 1262
+#define _tmp_33_type 1263
+#define _tmp_34_type 1264
+#define _tmp_35_type 1265
+#define _loop0_36_type 1266
+#define _loop0_37_type 1267
+#define _loop0_38_type 1268
+#define _loop1_39_type 1269
+#define _loop0_40_type 1270
+#define _loop1_41_type 1271
+#define _loop1_42_type 1272
+#define _loop1_43_type 1273
+#define _loop0_44_type 1274
+#define _loop1_45_type 1275
+#define _loop0_46_type 1276
+#define _loop1_47_type 1277
+#define _loop0_48_type 1278
+#define _loop0_49_type 1279
+#define _loop1_50_type 1280
+#define _loop0_52_type 1281
+#define _gather_51_type 1282
+#define _loop0_54_type 1283
+#define _gather_53_type 1284
+#define _loop0_56_type 1285
+#define _gather_55_type 1286
+#define _loop0_58_type 1287
+#define _gather_57_type 1288
+#define _tmp_59_type 1289
+#define _loop1_60_type 1290
+#define _loop1_61_type 1291
+#define _tmp_62_type 1292
+#define _tmp_63_type 1293
+#define _loop1_64_type 1294
+#define _loop0_66_type 1295
+#define _gather_65_type 1296
+#define _tmp_67_type 1297
+#define _tmp_68_type 1298
+#define _tmp_69_type 1299
+#define _tmp_70_type 1300
+#define _loop0_72_type 1301
+#define _gather_71_type 1302
+#define _loop0_74_type 1303
+#define _gather_73_type 1304
+#define _tmp_75_type 1305
+#define _loop0_77_type 1306
+#define _gather_76_type 1307
+#define _loop0_79_type 1308
+#define _gather_78_type 1309
+#define _loop1_80_type 1310
+#define _loop1_81_type 1311
+#define _loop0_83_type 1312
+#define _gather_82_type 1313
+#define _loop1_84_type 1314
+#define _loop1_85_type 1315
+#define _loop1_86_type 1316
+#define _tmp_87_type 1317
+#define _loop0_89_type 1318
+#define _gather_88_type 1319
+#define _tmp_90_type 1320
+#define _tmp_91_type 1321
+#define _tmp_92_type 1322
+#define _tmp_93_type 1323
+#define _tmp_94_type 1324
+#define _loop0_95_type 1325
+#define _loop0_96_type 1326
+#define _loop0_97_type 1327
+#define _loop1_98_type 1328
+#define _loop0_99_type 1329
+#define _loop1_100_type 1330
+#define _loop1_101_type 1331
+#define _loop1_102_type 1332
+#define _loop0_103_type 1333
+#define _loop1_104_type 1334
+#define _loop0_105_type 1335
+#define _loop1_106_type 1336
+#define _loop0_107_type 1337
+#define _loop1_108_type 1338
+#define _loop1_109_type 1339
+#define _tmp_110_type 1340
+#define _loop0_112_type 1341
+#define _gather_111_type 1342
+#define _loop1_113_type 1343
+#define _loop0_114_type 1344
+#define _loop0_115_type 1345
+#define _tmp_116_type 1346
+#define _loop0_118_type 1347
+#define _gather_117_type 1348
+#define _tmp_119_type 1349
+#define _loop0_121_type 1350
+#define _gather_120_type 1351
+#define _loop0_123_type 1352
+#define _gather_122_type 1353
+#define _loop0_125_type 1354
+#define _gather_124_type 1355
+#define _loop0_127_type 1356
+#define _gather_126_type 1357
+#define _loop0_128_type 1358
+#define _loop0_130_type 1359
+#define _gather_129_type 1360
+#define _loop1_131_type 1361
+#define _tmp_132_type 1362
+#define _loop0_134_type 1363
+#define _gather_133_type 1364
+#define _loop0_136_type 1365
+#define _gather_135_type 1366
+#define _loop0_138_type 1367
+#define _gather_137_type 1368
+#define _loop0_140_type 1369
+#define _gather_139_type 1370
+#define _loop0_142_type 1371
+#define _gather_141_type 1372
+#define _tmp_143_type 1373
+#define _tmp_144_type 1374
+#define _tmp_145_type 1375
+#define _tmp_146_type 1376
+#define _tmp_147_type 1377
+#define _tmp_148_type 1378
+#define _tmp_149_type 1379
+#define _tmp_150_type 1380
+#define _tmp_151_type 1381
+#define _loop0_152_type 1382
+#define _loop0_153_type 1383
+#define _loop0_154_type 1384
+#define _tmp_155_type 1385
+#define _tmp_156_type 1386
+#define _tmp_157_type 1387
+#define _tmp_158_type 1388
+#define _loop0_159_type 1389
+#define _loop0_160_type 1390
+#define _loop1_161_type 1391
+#define _tmp_162_type 1392
+#define _loop0_163_type 1393
+#define _tmp_164_type 1394
+#define _loop0_165_type 1395
+#define _tmp_166_type 1396
+#define _loop0_167_type 1397
+#define _loop1_168_type 1398
+#define _tmp_169_type 1399
+#define _tmp_170_type 1400
+#define _tmp_171_type 1401
+#define _loop0_172_type 1402
+#define _tmp_173_type 1403
+#define _tmp_174_type 1404
+#define _loop1_175_type 1405
+#define _loop0_176_type 1406
+#define _loop0_177_type 1407
+#define _loop0_179_type 1408
+#define _gather_178_type 1409
+#define _tmp_180_type 1410
+#define _loop0_181_type 1411
+#define _tmp_182_type 1412
+#define _loop0_183_type 1413
+#define _tmp_184_type 1414
+#define _loop0_185_type 1415
+#define _loop1_186_type 1416
+#define _loop1_187_type 1417
+#define _tmp_188_type 1418
+#define _tmp_189_type 1419
+#define _loop0_190_type 1420
+#define _tmp_191_type 1421
+#define _tmp_192_type 1422
+#define _tmp_193_type 1423
+#define _loop0_195_type 1424
+#define _gather_194_type 1425
+#define _loop0_197_type 1426
+#define _gather_196_type 1427
+#define _loop0_199_type 1428
+#define _gather_198_type 1429
+#define _loop0_201_type 1430
+#define _gather_200_type 1431
+#define _tmp_202_type 1432
+#define _loop0_203_type 1433
+#define _loop1_204_type 1434
+#define _tmp_205_type 1435
+#define _loop0_206_type 1436
+#define _loop1_207_type 1437
+#define _tmp_208_type 1438
+#define _tmp_209_type 1439
+#define _tmp_210_type 1440
+#define _tmp_211_type 1441
+#define _tmp_212_type 1442
+#define _tmp_213_type 1443
+#define _tmp_214_type 1444
+#define _tmp_215_type 1445
+#define _tmp_216_type 1446
+#define _tmp_217_type 1447
+#define _loop0_219_type 1448
+#define _gather_218_type 1449
+#define _tmp_220_type 1450
+#define _tmp_221_type 1451
+#define _tmp_222_type 1452
+#define _tmp_223_type 1453
+#define _tmp_224_type 1454
+#define _tmp_225_type 1455
+#define _tmp_226_type 1456
+#define _tmp_227_type 1457
+#define _tmp_228_type 1458
+#define _tmp_229_type 1459
+#define _tmp_230_type 1460
+#define _tmp_231_type 1461
+#define _tmp_232_type 1462
+#define _tmp_233_type 1463
+#define _tmp_234_type 1464
+#define _tmp_235_type 1465
+#define _tmp_236_type 1466
+#define _tmp_237_type 1467
+#define _tmp_238_type 1468
+#define _tmp_239_type 1469
+#define _tmp_240_type 1470
+#define _tmp_241_type 1471
+#define _tmp_242_type 1472
+#define _tmp_243_type 1473
+#define _tmp_244_type 1474
+#define _tmp_245_type 1475
+#define _tmp_246_type 1476
+#define _tmp_247_type 1477
+#define _tmp_248_type 1478
+#define _tmp_249_type 1479
 
 static mod_ty file_rule(Parser *p);
 static mod_ty interactive_rule(Parser *p);
@@ -611,6 +614,7 @@ static stmt_ty if_stmt_rule(Parser *p);
 static stmt_ty elif_stmt_rule(Parser *p);
 static asdl_stmt_seq* else_block_rule(Parser *p);
 static stmt_ty while_stmt_rule(Parser *p);
+static stmt_ty until_stmt_rule(Parser *p);
 static stmt_ty for_stmt_rule(Parser *p);
 static stmt_ty with_stmt_rule(Parser *p);
 static withitem_ty with_item_rule(Parser *p);
@@ -780,6 +784,7 @@ static void *invalid_if_stmt_rule(Parser *p);
 static void *invalid_elif_stmt_rule(Parser *p);
 static void *invalid_else_stmt_rule(Parser *p);
 static void *invalid_while_stmt_rule(Parser *p);
+static void *invalid_until_stmt_rule(Parser *p);
 static void *invalid_for_stmt_rule(Parser *p);
 static void *invalid_def_raw_rule(Parser *p);
 static void *invalid_class_def_raw_rule(Parser *p);
@@ -1702,7 +1707,7 @@ simple_stmt_rule(Parser *p)
         D(fprintf(stderr, "%*c> simple_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'return' return_stmt"));
         stmt_ty return_stmt_var;
         if (
-            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 519)  // token='return'
+            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 520)  // token='return'
             &&
             (return_stmt_var = return_stmt_rule(p))  // return_stmt
         )
@@ -1744,7 +1749,7 @@ simple_stmt_rule(Parser *p)
         D(fprintf(stderr, "%*c> simple_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'raise' raise_stmt"));
         stmt_ty raise_stmt_var;
         if (
-            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 522)  // token='raise'
+            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 523)  // token='raise'
             &&
             (raise_stmt_var = raise_stmt_rule(p))  // raise_stmt
         )
@@ -1798,7 +1803,7 @@ simple_stmt_rule(Parser *p)
         D(fprintf(stderr, "%*c> simple_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'del' del_stmt"));
         stmt_ty del_stmt_var;
         if (
-            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 603)  // token='del'
+            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 605)  // token='del'
             &&
             (del_stmt_var = del_stmt_rule(p))  // del_stmt
         )
@@ -1819,7 +1824,7 @@ simple_stmt_rule(Parser *p)
         D(fprintf(stderr, "%*c> simple_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'yield' yield_stmt"));
         stmt_ty yield_stmt_var;
         if (
-            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 573)  // token='yield'
+            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 575)  // token='yield'
             &&
             (yield_stmt_var = yield_stmt_rule(p))  // yield_stmt
         )
@@ -1840,7 +1845,7 @@ simple_stmt_rule(Parser *p)
         D(fprintf(stderr, "%*c> simple_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'assert' assert_stmt"));
         stmt_ty assert_stmt_var;
         if (
-            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 526)  // token='assert'
+            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 527)  // token='assert'
             &&
             (assert_stmt_var = assert_stmt_rule(p))  // assert_stmt
         )
@@ -1927,7 +1932,7 @@ simple_stmt_rule(Parser *p)
         D(fprintf(stderr, "%*c> simple_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'global' global_stmt"));
         stmt_ty global_stmt_var;
         if (
-            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 523)  // token='global'
+            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 524)  // token='global'
             &&
             (global_stmt_var = global_stmt_rule(p))  // global_stmt
         )
@@ -1948,7 +1953,7 @@ simple_stmt_rule(Parser *p)
         D(fprintf(stderr, "%*c> simple_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'nonlocal' nonlocal_stmt"));
         stmt_ty nonlocal_stmt_var;
         if (
-            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 524)  // token='nonlocal'
+            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 525)  // token='nonlocal'
             &&
             (nonlocal_stmt_var = nonlocal_stmt_rule(p))  // nonlocal_stmt
         )
@@ -1976,6 +1981,7 @@ simple_stmt_rule(Parser *p)
 //     | &('for' | ASYNC) for_stmt
 //     | &'try' try_stmt
 //     | &'while' while_stmt
+//     | &'until' until_stmt
 //     | match_stmt
 static stmt_ty
 compound_stmt_rule(Parser *p)
@@ -2019,7 +2025,7 @@ compound_stmt_rule(Parser *p)
         D(fprintf(stderr, "%*c> compound_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'if' if_stmt"));
         stmt_ty if_stmt_var;
         if (
-            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 639)  // token='if'
+            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 641)  // token='if'
             &&
             (if_stmt_var = if_stmt_rule(p))  // if_stmt
         )
@@ -2103,7 +2109,7 @@ compound_stmt_rule(Parser *p)
         D(fprintf(stderr, "%*c> compound_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'try' try_stmt"));
         stmt_ty try_stmt_var;
         if (
-            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 621)  // token='try'
+            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 623)  // token='try'
             &&
             (try_stmt_var = try_stmt_rule(p))  // try_stmt
         )
@@ -2124,7 +2130,7 @@ compound_stmt_rule(Parser *p)
         D(fprintf(stderr, "%*c> compound_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'while' while_stmt"));
         stmt_ty while_stmt_var;
         if (
-            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 644)  // token='while'
+            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 646)  // token='while'
             &&
             (while_stmt_var = while_stmt_rule(p))  // while_stmt
         )
@@ -2137,6 +2143,27 @@ compound_stmt_rule(Parser *p)
         D(fprintf(stderr, "%*c%s compound_stmt[%d-%d]: %s failed!\n", p->level, ' ',
                   p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'while' while_stmt"));
     }
+    { // &'until' until_stmt
+        if (p->error_indicator) {
+            p->level--;
+            return NULL;
+        }
+        D(fprintf(stderr, "%*c> compound_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "&'until' until_stmt"));
+        stmt_ty until_stmt_var;
+        if (
+            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 648)  // token='until'
+            &&
+            (until_stmt_var = until_stmt_rule(p))  // until_stmt
+        )
+        {
+            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "&'until' until_stmt"));
+            _res = until_stmt_var;
+            goto done;
+        }
+        p->mark = _mark;
+        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d]: %s failed!\n", p->level, ' ',
+                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "&'until' until_stmt"));
+    }
     { // match_stmt
         if (p->error_indicator) {
             p->level--;
@@ -2821,7 +2848,7 @@ return_stmt_rule(Parser *p)
         Token * _keyword;
         void *a;
         if (
-            (_keyword = _PyPegen_expect_token(p, 519))  // token='return'
+            (_keyword = _PyPegen_expect_token(p, 520))  // token='return'
             &&
             (a = star_expressions_rule(p), !p->error_indicator)  // star_expressions?
         )
@@ -2887,7 +2914,7 @@ raise_stmt_rule(Parser *p)
         expr_ty a;
         void *b;
         if (
-            (_keyword = _PyPegen_expect_token(p, 522))  // token='raise'
+            (_keyword = _PyPegen_expect_token(p, 523))  // token='raise'
             &&
             (a = expression_rule(p))  // expression
             &&
@@ -2924,7 +2951,7 @@ raise_stmt_rule(Parser *p)
         D(fprintf(stderr, "%*c> raise_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'raise'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 522))  // token='raise'
+            (_keyword = _PyPegen_expect_token(p, 523))  // token='raise'
         )
         {
             D(fprintf(stderr, "%*c+ raise_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'raise'"));
@@ -2987,7 +3014,7 @@ global_stmt_rule(Parser *p)
         Token * _keyword;
         asdl_expr_seq* a;
         if (
-            (_keyword = _PyPegen_expect_token(p, 523))  // token='global'
+            (_keyword = _PyPegen_expect_token(p, 524))  // token='global'
             &&
             (a = (asdl_expr_seq*)_gather_18_rule(p))  // ','.NAME+
         )
@@ -3052,7 +3079,7 @@ nonlocal_stmt_rule(Parser *p)
         Token * _keyword;
         asdl_expr_seq* a;
         if (
-            (_keyword = _PyPegen_expect_token(p, 524))  // token='nonlocal'
+            (_keyword = _PyPegen_expect_token(p, 525))  // token='nonlocal'
             &&
             (a = (asdl_expr_seq*)_gather_20_rule(p))  // ','.NAME+
         )
@@ -3117,7 +3144,7 @@ del_stmt_rule(Parser *p)
         Token * _keyword;
         asdl_expr_seq* a;
         if (
-            (_keyword = _PyPegen_expect_token(p, 603))  // token='del'
+            (_keyword = _PyPegen_expect_token(p, 605))  // token='del'
             &&
             (a = del_targets_rule(p))  // del_targets
             &&
@@ -3266,7 +3293,7 @@ assert_stmt_rule(Parser *p)
         expr_ty a;
         void *b;
         if (
-            (_keyword = _PyPegen_expect_token(p, 526))  // token='assert'
+            (_keyword = _PyPegen_expect_token(p, 527))  // token='assert'
             &&
             (a = expression_rule(p))  // expression
             &&
@@ -3391,7 +3418,7 @@ import_name_rule(Parser *p)
         Token * _keyword;
         asdl_alias_seq* a;
         if (
-            (_keyword = _PyPegen_expect_token(p, 531))  // token='import'
+            (_keyword = _PyPegen_expect_token(p, 532))  // token='import'
             &&
             (a = dotted_as_names_rule(p))  // dotted_as_names
         )
@@ -3461,13 +3488,13 @@ import_from_rule(Parser *p)
         expr_ty b;
         asdl_alias_seq* c;
         if (
-            (_keyword = _PyPegen_expect_token(p, 572))  // token='from'
+            (_keyword = _PyPegen_expect_token(p, 574))  // token='from'
             &&
             (a = _loop0_24_rule(p))  // (('.' | '...'))*
             &&
             (b = dotted_name_rule(p))  // dotted_name
             &&
-            (_keyword_1 = _PyPegen_expect_token(p, 531))  // token='import'
+            (_keyword_1 = _PyPegen_expect_token(p, 532))  // token='import'
             &&
             (c = import_from_targets_rule(p))  // import_from_targets
         )
@@ -3505,11 +3532,11 @@ import_from_rule(Parser *p)
         asdl_seq * a;
         asdl_alias_seq* b;
         if (
-            (_keyword = _PyPegen_expect_token(p, 572))  // token='from'
+            (_keyword = _PyPegen_expect_token(p, 574))  // token='from'
             &&
             (a = _loop1_25_rule(p))  // (('.' | '...'))+
             &&
-            (_keyword_1 = _PyPegen_expect_token(p, 531))  // token='import'
+            (_keyword_1 = _PyPegen_expect_token(p, 532))  // token='import'
             &&
             (b = import_from_targets_rule(p))  // import_from_targets
         )
@@ -4266,7 +4293,7 @@ class_def_raw_rule(Parser *p)
         void *b;
         asdl_stmt_seq* c;
         if (
-            (_keyword = _PyPegen_expect_token(p, 651))  // token='class'
+            (_keyword = _PyPegen_expect_token(p, 655))  // token='class'
             &&
             (a = _PyPegen_name_token(p))  // NAME
             &&
@@ -4432,7 +4459,7 @@ function_def_raw_rule(Parser *p)
         void *params;
         void *tc;
         if (
-            (_keyword = _PyPegen_expect_token(p, 649))  // token='def'
+            (_keyword = _PyPegen_expect_token(p, 653))  // token='def'
             &&
             (n = _PyPegen_name_token(p))  // NAME
             &&
@@ -4492,7 +4519,7 @@ function_def_raw_rule(Parser *p)
         if (
             (async_var = _PyPegen_expect_token(p, ASYNC))  // token='ASYNC'
             &&
-            (_keyword = _PyPegen_expect_token(p, 649))  // token='def'
+            (_keyword = _PyPegen_expect_token(p, 653))  // token='def'
             &&
             (n = _PyPegen_name_token(p))  // NAME
             &&
@@ -5844,7 +5871,7 @@ if_stmt_rule(Parser *p)
         asdl_stmt_seq* b;
         stmt_ty c;
         if (
-            (_keyword = _PyPegen_expect_token(p, 639))  // token='if'
+            (_keyword = _PyPegen_expect_token(p, 641))  // token='if'
             &&
             (a = named_expression_rule(p))  // named_expression
             &&
@@ -5889,7 +5916,7 @@ if_stmt_rule(Parser *p)
         asdl_stmt_seq* b;
         void *c;
         if (
-            (_keyword = _PyPegen_expect_token(p, 639))  // token='if'
+            (_keyword = _PyPegen_expect_token(p, 641))  // token='if'
             &&
             (a = named_expression_rule(p))  // named_expression
             &&
@@ -5985,7 +6012,7 @@ elif_stmt_rule(Parser *p)
         asdl_stmt_seq* b;
         stmt_ty c;
         if (
-            (_keyword = _PyPegen_expect_token(p, 641))  // token='elif'
+            (_keyword = _PyPegen_expect_token(p, 643))  // token='elif'
             &&
             (a = named_expression_rule(p))  // named_expression
             &&
@@ -6030,7 +6057,7 @@ elif_stmt_rule(Parser *p)
         asdl_stmt_seq* b;
         void *c;
         if (
-            (_keyword = _PyPegen_expect_token(p, 641))  // token='elif'
+            (_keyword = _PyPegen_expect_token(p, 643))  // token='elif'
             &&
             (a = named_expression_rule(p))  // named_expression
             &&
@@ -6112,7 +6139,7 @@ else_block_rule(Parser *p)
         Token * _literal;
         asdl_stmt_seq* b;
         if (
-            (_keyword = _PyPegen_expect_token(p, 642))  // token='else'
+            (_keyword = _PyPegen_expect_token(p, 644))  // token='else'
             &&
             (_literal = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
             &&
@@ -6192,7 +6219,7 @@ while_stmt_rule(Parser *p)
         asdl_stmt_seq* b;
         void *c;
         if (
-            (_keyword = _PyPegen_expect_token(p, 644))  // token='while'
+            (_keyword = _PyPegen_expect_token(p, 646))  // token='while'
             &&
             (a = named_expression_rule(p))  // named_expression
             &&
@@ -6231,6 +6258,99 @@ while_stmt_rule(Parser *p)
     return _res;
 }
 
+// until_stmt: invalid_until_stmt | 'until' named_expression ':' block else_block?
+static stmt_ty
+until_stmt_rule(Parser *p)
+{
+    if (p->level++ == MAXSTACK) {
+        p->error_indicator = 1;
+        PyErr_NoMemory();
+    }
+    if (p->error_indicator) {
+        p->level--;
+        return NULL;
+    }
+    stmt_ty _res = NULL;
+    int _mark = p->mark;
+    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
+        p->error_indicator = 1;
+        p->level--;
+        return NULL;
+    }
+    int _start_lineno = p->tokens[_mark]->lineno;
+    UNUSED(_start_lineno); // Only used by EXTRA macro
+    int _start_col_offset = p->tokens[_mark]->col_offset;
+    UNUSED(_start_col_offset); // Only used by EXTRA macro
+    if (p->call_invalid_rules) { // invalid_until_stmt
+        if (p->error_indicator) {
+            p->level--;
+            return NULL;
+        }
+        D(fprintf(stderr, "%*c> until_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "invalid_until_stmt"));
+        void *invalid_until_stmt_var;
+        if (
+            (invalid_until_stmt_var = invalid_until_stmt_rule(p))  // invalid_until_stmt
+        )
+        {
+            D(fprintf(stderr, "%*c+ until_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "invalid_until_stmt"));
+            _res = invalid_until_stmt_var;
+            goto done;
+        }
+        p->mark = _mark;
+        D(fprintf(stderr, "%*c%s until_stmt[%d-%d]: %s failed!\n", p->level, ' ',
+                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "invalid_until_stmt"));
+    }
+    { // 'until' named_expression ':' block else_block?
+        if (p->error_indicator) {
+            p->level--;
+            return NULL;
+        }
+        D(fprintf(stderr, "%*c> until_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'until' named_expression ':' block else_block?"));
+        Token * _keyword;
+        Token * _literal;
+        expr_ty a;
+        asdl_stmt_seq* b;
+        void *c;
+        if (
+            (_keyword = _PyPegen_expect_token(p, 648))  // token='until'
+            &&
+            (a = named_expression_rule(p))  // named_expression
+            &&
+            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
+            &&
+            (b = block_rule(p))  // block
+            &&
+            (c = else_block_rule(p), !p->error_indicator)  // else_block?
+        )
+        {
+            D(fprintf(stderr, "%*c+ until_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'until' named_expression ':' block else_block?"));
+            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
+            if (_token == NULL) {
+                p->level--;
+                return NULL;
+            }
+            int _end_lineno = _token->end_lineno;
+            UNUSED(_end_lineno); // Only used by EXTRA macro
+            int _end_col_offset = _token->end_col_offset;
+            UNUSED(_end_col_offset); // Only used by EXTRA macro
+            _res = _PyAST_Until ( a , b , c , EXTRA );
+            if (_res == NULL && PyErr_Occurred()) {
+                p->error_indicator = 1;
+                p->level--;
+                return NULL;
+            }
+            goto done;
+        }
+        p->mark = _mark;
+        D(fprintf(stderr, "%*c%s until_stmt[%d-%d]: %s failed!\n", p->level, ' ',
+                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'until' named_expression ':' block else_block?"));
+    }
+    _res = NULL;
+  done:
+    p->level--;
+    return _res;
+}
+
 // for_stmt:
 //     | invalid_for_stmt
 //     | 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?
@@ -6293,11 +6413,11 @@ for_stmt_rule(Parser *p)
         expr_ty t;
         void *tc;
         if (
-            (_keyword = _PyPegen_expect_token(p, 647))  // token='for'
+            (_keyword = _PyPegen_expect_token(p, 651))  // token='for'
             &&
             (t = star_targets_rule(p))  // star_targets
             &&
-            (_keyword_1 = _PyPegen_expect_token(p, 648))  // token='in'
+            (_keyword_1 = _PyPegen_expect_token(p, 652))  // token='in'
             &&
             (_cut_var = 1)
             &&
@@ -6357,11 +6477,11 @@ for_stmt_rule(Parser *p)
         if (
             (async_var = _PyPegen_expect_token(p, ASYNC))  // token='ASYNC'
             &&
-            (_keyword = _PyPegen_expect_token(p, 647))  // token='for'
+            (_keyword = _PyPegen_expect_token(p, 651))  // token='for'
             &&
             (t = star_targets_rule(p))  // star_targets
             &&
-            (_keyword_1 = _PyPegen_expect_token(p, 648))  // token='in'
+            (_keyword_1 = _PyPegen_expect_token(p, 652))  // token='in'
             &&
             (_cut_var = 1)
             &&
@@ -6490,7 +6610,7 @@ with_stmt_rule(Parser *p)
         asdl_withitem_seq* a;
         asdl_stmt_seq* b;
         if (
-            (_keyword = _PyPegen_expect_token(p, 612))  // token='with'
+            (_keyword = _PyPegen_expect_token(p, 614))  // token='with'
             &&
             (_literal = _PyPegen_expect_token(p, 7))  // token='('
             &&
@@ -6539,7 +6659,7 @@ with_stmt_rule(Parser *p)
         asdl_stmt_seq* b;
         void *tc;
         if (
-            (_keyword = _PyPegen_expect_token(p, 612))  // token='with'
+            (_keyword = _PyPegen_expect_token(p, 614))  // token='with'
             &&
             (a = (asdl_withitem_seq*)_gather_53_rule(p))  // ','.with_item+
             &&
@@ -6590,7 +6710,7 @@ with_stmt_rule(Parser *p)
         if (
             (async_var = _PyPegen_expect_token(p, ASYNC))  // token='ASYNC'
             &&
-            (_keyword = _PyPegen_expect_token(p, 612))  // token='with'
+            (_keyword = _PyPegen_expect_token(p, 614))  // token='with'
             &&
             (_literal = _PyPegen_expect_token(p, 7))  // token='('
             &&
@@ -6642,7 +6762,7 @@ with_stmt_rule(Parser *p)
         if (
             (async_var = _PyPegen_expect_token(p, ASYNC))  // token='ASYNC'
             &&
-            (_keyword = _PyPegen_expect_token(p, 612))  // token='with'
+            (_keyword = _PyPegen_expect_token(p, 614))  // token='with'
             &&
             (a = (asdl_withitem_seq*)_gather_57_rule(p))  // ','.with_item+
             &&
@@ -6729,7 +6849,7 @@ with_item_rule(Parser *p)
         if (
             (e = expression_rule(p))  // expression
             &&
-            (_keyword = _PyPegen_expect_token(p, 637))  // token='as'
+            (_keyword = _PyPegen_expect_token(p, 639))  // token='as'
             &&
             (t = star_target_rule(p))  // star_target
             &&
@@ -6855,7 +6975,7 @@ try_stmt_rule(Parser *p)
         asdl_stmt_seq* b;
         asdl_stmt_seq* f;
         if (
-            (_keyword = _PyPegen_expect_token(p, 621))  // token='try'
+            (_keyword = _PyPegen_expect_token(p, 623))  // token='try'
             &&
             (_literal = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
             &&
@@ -6899,7 +7019,7 @@ try_stmt_rule(Parser *p)
         asdl_excepthandler_seq* ex;
         void *f;
         if (
-            (_keyword = _PyPegen_expect_token(p, 621))  // token='try'
+            (_keyword = _PyPegen_expect_token(p, 623))  // token='try'
             &&
             (_literal = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
             &&
@@ -6947,7 +7067,7 @@ try_stmt_rule(Parser *p)
         asdl_excepthandler_seq* ex;
         void *f;
         if (
-            (_keyword = _PyPegen_expect_token(p, 621))  // token='try'
+            (_keyword = _PyPegen_expect_token(p, 623))  // token='try'
             &&
             (_literal = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
             &&
@@ -7046,7 +7166,7 @@ except_block_rule(Parser *p)
         expr_ty e;
         void *t;
         if (
-            (_keyword = _PyPegen_expect_token(p, 634))  // token='except'
+            (_keyword = _PyPegen_expect_token(p, 636))  // token='except'
             &&
             (e = expression_rule(p))  // expression
             &&
@@ -7089,7 +7209,7 @@ except_block_rule(Parser *p)
         Token * _literal;
         asdl_stmt_seq* b;
         if (
-            (_keyword = _PyPegen_expect_token(p, 634))  // token='except'
+            (_keyword = _PyPegen_expect_token(p, 636))  // token='except'
             &&
             (_literal = _PyPegen_expect_token(p, 11))  // token=':'
             &&
@@ -7201,7 +7321,7 @@ except_star_block_rule(Parser *p)
         expr_ty e;
         void *t;
         if (
-            (_keyword = _PyPegen_expect_token(p, 634))  // token='except'
+            (_keyword = _PyPegen_expect_token(p, 636))  // token='except'
             &&
             (_literal = _PyPegen_expect_token(p, 16))  // token='*'
             &&
@@ -7304,7 +7424,7 @@ finally_block_rule(Parser *p)
         Token * _literal;
         asdl_stmt_seq* a;
         if (
-            (_keyword = _PyPegen_expect_token(p, 630))  // token='finally'
+            (_keyword = _PyPegen_expect_token(p, 632))  // token='finally'
             &&
             (_literal = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
             &&
@@ -7616,7 +7736,7 @@ guard_rule(Parser *p)
         Token * _keyword;
         expr_ty guard;
         if (
-            (_keyword = _PyPegen_expect_token(p, 639))  // token='if'
+            (_keyword = _PyPegen_expect_token(p, 641))  // token='if'
             &&
             (guard = named_expression_rule(p))  // named_expression
         )
@@ -7814,7 +7934,7 @@ as_pattern_rule(Parser *p)
         if (
             (pattern = or_pattern_rule(p))  // or_pattern
             &&
-            (_keyword = _PyPegen_expect_token(p, 637))  // token='as'
+            (_keyword = _PyPegen_expect_token(p, 639))  // token='as'
             &&
             (target = pattern_capture_target_rule(p))  // pattern_capture_target
         )
@@ -8251,7 +8371,7 @@ literal_pattern_rule(Parser *p)
         D(fprintf(stderr, "%*c> literal_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'None'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 601))  // token='None'
+            (_keyword = _PyPegen_expect_token(p, 603))  // token='None'
         )
         {
             D(fprintf(stderr, "%*c+ literal_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'None'"));
@@ -8284,7 +8404,7 @@ literal_pattern_rule(Parser *p)
         D(fprintf(stderr, "%*c> literal_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'True'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 600))  // token='True'
+            (_keyword = _PyPegen_expect_token(p, 602))  // token='True'
         )
         {
             D(fprintf(stderr, "%*c+ literal_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'True'"));
@@ -8317,7 +8437,7 @@ literal_pattern_rule(Parser *p)
         D(fprintf(stderr, "%*c> literal_pattern[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'False'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 602))  // token='False'
+            (_keyword = _PyPegen_expect_token(p, 604))  // token='False'
         )
         {
             D(fprintf(stderr, "%*c+ literal_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'False'"));
@@ -8444,7 +8564,7 @@ literal_expr_rule(Parser *p)
         D(fprintf(stderr, "%*c> literal_expr[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'None'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 601))  // token='None'
+            (_keyword = _PyPegen_expect_token(p, 603))  // token='None'
         )
         {
             D(fprintf(stderr, "%*c+ literal_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'None'"));
@@ -8477,7 +8597,7 @@ literal_expr_rule(Parser *p)
         D(fprintf(stderr, "%*c> literal_expr[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'True'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 600))  // token='True'
+            (_keyword = _PyPegen_expect_token(p, 602))  // token='True'
         )
         {
             D(fprintf(stderr, "%*c+ literal_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'True'"));
@@ -8510,7 +8630,7 @@ literal_expr_rule(Parser *p)
         D(fprintf(stderr, "%*c> literal_expr[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'False'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 602))  // token='False'
+            (_keyword = _PyPegen_expect_token(p, 604))  // token='False'
         )
         {
             D(fprintf(stderr, "%*c+ literal_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'False'"));
@@ -10642,11 +10762,11 @@ expression_rule(Parser *p)
         if (
             (a = disjunction_rule(p))  // disjunction
             &&
-            (_keyword = _PyPegen_expect_token(p, 639))  // token='if'
+            (_keyword = _PyPegen_expect_token(p, 641))  // token='if'
             &&
             (b = disjunction_rule(p))  // disjunction
             &&
-            (_keyword_1 = _PyPegen_expect_token(p, 642))  // token='else'
+            (_keyword_1 = _PyPegen_expect_token(p, 644))  // token='else'
             &&
             (c = expression_rule(p))  // expression
         )
@@ -10751,9 +10871,9 @@ yield_expr_rule(Parser *p)
         Token * _keyword_1;
         expr_ty a;
         if (
-            (_keyword = _PyPegen_expect_token(p, 573))  // token='yield'
+            (_keyword = _PyPegen_expect_token(p, 575))  // token='yield'
             &&
-            (_keyword_1 = _PyPegen_expect_token(p, 572))  // token='from'
+            (_keyword_1 = _PyPegen_expect_token(p, 574))  // token='from'
             &&
             (a = expression_rule(p))  // expression
         )
@@ -10789,7 +10909,7 @@ yield_expr_rule(Parser *p)
         Token * _keyword;
         void *a;
         if (
-            (_keyword = _PyPegen_expect_token(p, 573))  // token='yield'
+            (_keyword = _PyPegen_expect_token(p, 575))  // token='yield'
             &&
             (a = star_expressions_rule(p), !p->error_indicator)  // star_expressions?
         )
@@ -11538,7 +11658,7 @@ inversion_rule(Parser *p)
         Token * _keyword;
         expr_ty a;
         if (
-            (_keyword = _PyPegen_expect_token(p, 581))  // token='not'
+            (_keyword = _PyPegen_expect_token(p, 583))  // token='not'
             &&
             (a = inversion_rule(p))  // inversion
         )
@@ -12201,9 +12321,9 @@ notin_bitwise_or_rule(Parser *p)
         Token * _keyword_1;
         expr_ty a;
         if (
-            (_keyword = _PyPegen_expect_token(p, 581))  // token='not'
+            (_keyword = _PyPegen_expect_token(p, 583))  // token='not'
             &&
-            (_keyword_1 = _PyPegen_expect_token(p, 648))  // token='in'
+            (_keyword_1 = _PyPegen_expect_token(p, 652))  // token='in'
             &&
             (a = bitwise_or_rule(p))  // bitwise_or
         )
@@ -12250,7 +12370,7 @@ in_bitwise_or_rule(Parser *p)
         Token * _keyword;
         expr_ty a;
         if (
-            (_keyword = _PyPegen_expect_token(p, 648))  // token='in'
+            (_keyword = _PyPegen_expect_token(p, 652))  // token='in'
             &&
             (a = bitwise_or_rule(p))  // bitwise_or
         )
@@ -12298,9 +12418,9 @@ isnot_bitwise_or_rule(Parser *p)
         Token * _keyword_1;
         expr_ty a;
         if (
-            (_keyword = _PyPegen_expect_token(p, 582))  // token='is'
+            (_keyword = _PyPegen_expect_token(p, 584))  // token='is'
             &&
-            (_keyword_1 = _PyPegen_expect_token(p, 581))  // token='not'
+            (_keyword_1 = _PyPegen_expect_token(p, 583))  // token='not'
             &&
             (a = bitwise_or_rule(p))  // bitwise_or
         )
@@ -12347,7 +12467,7 @@ is_bitwise_or_rule(Parser *p)
         Token * _keyword;
         expr_ty a;
         if (
-            (_keyword = _PyPegen_expect_token(p, 582))  // token='is'
+            (_keyword = _PyPegen_expect_token(p, 584))  // token='is'
             &&
             (a = bitwise_or_rule(p))  // bitwise_or
         )
@@ -14188,7 +14308,7 @@ atom_rule(Parser *p)
         D(fprintf(stderr, "%*c> atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'True'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 600))  // token='True'
+            (_keyword = _PyPegen_expect_token(p, 602))  // token='True'
         )
         {
             D(fprintf(stderr, "%*c+ atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'True'"));
@@ -14221,7 +14341,7 @@ atom_rule(Parser *p)
         D(fprintf(stderr, "%*c> atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'False'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 602))  // token='False'
+            (_keyword = _PyPegen_expect_token(p, 604))  // token='False'
         )
         {
             D(fprintf(stderr, "%*c+ atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'False'"));
@@ -14254,7 +14374,7 @@ atom_rule(Parser *p)
         D(fprintf(stderr, "%*c> atom[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'None'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 601))  // token='None'
+            (_keyword = _PyPegen_expect_token(p, 603))  // token='None'
         )
         {
             D(fprintf(stderr, "%*c+ atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'None'"));
@@ -14524,7 +14644,7 @@ lambdef_rule(Parser *p)
         void *a;
         expr_ty b;
         if (
-            (_keyword = _PyPegen_expect_token(p, 586))  // token='lambda'
+            (_keyword = _PyPegen_expect_token(p, 588))  // token='lambda'
             &&
             (a = lambda_params_rule(p), !p->error_indicator)  // lambda_params?
             &&
@@ -16035,11 +16155,11 @@ for_if_clause_rule(Parser *p)
         if (
             (async_var = _PyPegen_expect_token(p, ASYNC))  // token='ASYNC'
             &&
-            (_keyword = _PyPegen_expect_token(p, 647))  // token='for'
+            (_keyword = _PyPegen_expect_token(p, 651))  // token='for'
             &&
             (a = star_targets_rule(p))  // star_targets
             &&
-            (_keyword_1 = _PyPegen_expect_token(p, 648))  // token='in'
+            (_keyword_1 = _PyPegen_expect_token(p, 652))  // token='in'
             &&
             (_cut_var = 1)
             &&
@@ -16078,11 +16198,11 @@ for_if_clause_rule(Parser *p)
         expr_ty b;
         asdl_expr_seq* c;
         if (
-            (_keyword = _PyPegen_expect_token(p, 647))  // token='for'
+            (_keyword = _PyPegen_expect_token(p, 651))  // token='for'
             &&
             (a = star_targets_rule(p))  // star_targets
             &&
-            (_keyword_1 = _PyPegen_expect_token(p, 648))  // token='in'
+            (_keyword_1 = _PyPegen_expect_token(p, 652))  // token='in'
             &&
             (_cut_var = 1)
             &&
@@ -19284,11 +19404,11 @@ expression_without_invalid_rule(Parser *p)
         if (
             (a = disjunction_rule(p))  // disjunction
             &&
-            (_keyword = _PyPegen_expect_token(p, 639))  // token='if'
+            (_keyword = _PyPegen_expect_token(p, 641))  // token='if'
             &&
             (b = disjunction_rule(p))  // disjunction
             &&
-            (_keyword_1 = _PyPegen_expect_token(p, 642))  // token='else'
+            (_keyword_1 = _PyPegen_expect_token(p, 644))  // token='else'
             &&
             (c = expression_rule(p))  // expression
         )
@@ -19470,7 +19590,7 @@ invalid_expression_rule(Parser *p)
         if (
             (a = disjunction_rule(p))  // disjunction
             &&
-            (_keyword = _PyPegen_expect_token(p, 639))  // token='if'
+            (_keyword = _PyPegen_expect_token(p, 641))  // token='if'
             &&
             (b = disjunction_rule(p))  // disjunction
             &&
@@ -19943,7 +20063,7 @@ invalid_del_stmt_rule(Parser *p)
         Token * _keyword;
         expr_ty a;
         if (
-            (_keyword = _PyPegen_expect_token(p, 603))  // token='del'
+            (_keyword = _PyPegen_expect_token(p, 605))  // token='del'
             &&
             (a = star_expressions_rule(p))  // star_expressions
         )
@@ -21385,7 +21505,7 @@ invalid_with_item_rule(Parser *p)
         if (
             (expression_var = expression_rule(p))  // expression
             &&
-            (_keyword = _PyPegen_expect_token(p, 637))  // token='as'
+            (_keyword = _PyPegen_expect_token(p, 639))  // token='as'
             &&
             (a = expression_rule(p))  // expression
             &&
@@ -21438,7 +21558,7 @@ invalid_for_target_rule(Parser *p)
         if (
             (_opt_var = _PyPegen_expect_token(p, ASYNC), !p->error_indicator)  // ASYNC?
             &&
-            (_keyword = _PyPegen_expect_token(p, 647))  // token='for'
+            (_keyword = _PyPegen_expect_token(p, 651))  // token='for'
             &&
             (a = star_expressions_rule(p))  // star_expressions
         )
@@ -21625,7 +21745,7 @@ invalid_with_stmt_rule(Parser *p)
         if (
             (_opt_var = _PyPegen_expect_token(p, ASYNC), !p->error_indicator)  // ASYNC?
             &&
-            (_keyword = _PyPegen_expect_token(p, 612))  // token='with'
+            (_keyword = _PyPegen_expect_token(p, 614))  // token='with'
             &&
             (_gather_194_var = _gather_194_rule(p))  // ','.(expression ['as' star_target])+
             &&
@@ -21663,7 +21783,7 @@ invalid_with_stmt_rule(Parser *p)
         if (
             (_opt_var = _PyPegen_expect_token(p, ASYNC), !p->error_indicator)  // ASYNC?
             &&
-            (_keyword = _PyPegen_expect_token(p, 612))  // token='with'
+            (_keyword = _PyPegen_expect_token(p, 614))  // token='with'
             &&
             (_literal = _PyPegen_expect_token(p, 7))  // token='('
             &&
@@ -21726,7 +21846,7 @@ invalid_with_stmt_indent_rule(Parser *p)
         if (
             (_opt_var = _PyPegen_expect_token(p, ASYNC), !p->error_indicator)  // ASYNC?
             &&
-            (a = _PyPegen_expect_token(p, 612))  // token='with'
+            (a = _PyPegen_expect_token(p, 614))  // token='with'
             &&
             (_gather_198_var = _gather_198_rule(p))  // ','.(expression ['as' star_target])+
             &&
@@ -21769,7 +21889,7 @@ invalid_with_stmt_indent_rule(Parser *p)
         if (
             (_opt_var = _PyPegen_expect_token(p, ASYNC), !p->error_indicator)  // ASYNC?
             &&
-            (a = _PyPegen_expect_token(p, 612))  // token='with'
+            (a = _PyPegen_expect_token(p, 614))  // token='with'
             &&
             (_literal = _PyPegen_expect_token(p, 7))  // token='('
             &&
@@ -21833,7 +21953,7 @@ invalid_try_stmt_rule(Parser *p)
         Token * a;
         Token * newline_var;
         if (
-            (a = _PyPegen_expect_token(p, 621))  // token='try'
+            (a = _PyPegen_expect_token(p, 623))  // token='try'
             &&
             (_literal = _PyPegen_expect_token(p, 11))  // token=':'
             &&
@@ -21865,7 +21985,7 @@ invalid_try_stmt_rule(Parser *p)
         Token * _literal;
         asdl_stmt_seq* block_var;
         if (
-            (_keyword = _PyPegen_expect_token(p, 621))  // token='try'
+            (_keyword = _PyPegen_expect_token(p, 623))  // token='try'
             &&
             (_literal = _PyPegen_expect_token(p, 11))  // token=':'
             &&
@@ -21904,7 +22024,7 @@ invalid_try_stmt_rule(Parser *p)
         Token * b;
         expr_ty expression_var;
         if (
-            (_keyword = _PyPegen_expect_token(p, 621))  // token='try'
+            (_keyword = _PyPegen_expect_token(p, 623))  // token='try'
             &&
             (_literal = _PyPegen_expect_token(p, 11))  // token=':'
             &&
@@ -21912,7 +22032,7 @@ invalid_try_stmt_rule(Parser *p)
             &&
             (_loop1_204_var = _loop1_204_rule(p))  // except_block+
             &&
-            (a = _PyPegen_expect_token(p, 634))  // token='except'
+            (a = _PyPegen_expect_token(p, 636))  // token='except'
             &&
             (b = _PyPegen_expect_token(p, 16))  // token='*'
             &&
@@ -21951,7 +22071,7 @@ invalid_try_stmt_rule(Parser *p)
         UNUSED(_opt_var); // Silence compiler warnings
         Token * a;
         if (
-            (_keyword = _PyPegen_expect_token(p, 621))  // token='try'
+            (_keyword = _PyPegen_expect_token(p, 623))  // token='try'
             &&
             (_literal = _PyPegen_expect_token(p, 11))  // token=':'
             &&
@@ -21959,7 +22079,7 @@ invalid_try_stmt_rule(Parser *p)
             &&
             (_loop1_207_var = _loop1_207_rule(p))  // except_star_block+
             &&
-            (a = _PyPegen_expect_token(p, 634))  // token='except'
+            (a = _PyPegen_expect_token(p, 636))  // token='except'
             &&
             (_opt_var = _tmp_208_rule(p), !p->error_indicator)  // [expression ['as' NAME]]
             &&
@@ -22019,7 +22139,7 @@ invalid_except_stmt_rule(Parser *p)
         expr_ty a;
         expr_ty expressions_var;
         if (
-            (_keyword = _PyPegen_expect_token(p, 634))  // token='except'
+            (_keyword = _PyPegen_expect_token(p, 636))  // token='except'
             &&
             (_opt_var = _PyPegen_expect_token(p, 16), !p->error_indicator)  // '*'?
             &&
@@ -22061,7 +22181,7 @@ invalid_except_stmt_rule(Parser *p)
         expr_ty expression_var;
         Token * newline_var;
         if (
-            (a = _PyPegen_expect_token(p, 634))  // token='except'
+            (a = _PyPegen_expect_token(p, 636))  // token='except'
             &&
             (_opt_var = _PyPegen_expect_token(p, 16), !p->error_indicator)  // '*'?
             &&
@@ -22094,7 +22214,7 @@ invalid_except_stmt_rule(Parser *p)
         Token * a;
         Token * newline_var;
         if (
-            (a = _PyPegen_expect_token(p, 634))  // token='except'
+            (a = _PyPegen_expect_token(p, 636))  // token='except'
             &&
             (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
         )
@@ -22122,7 +22242,7 @@ invalid_except_stmt_rule(Parser *p)
         void *_tmp_211_var;
         Token * a;
         if (
-            (a = _PyPegen_expect_token(p, 634))  // token='except'
+            (a = _PyPegen_expect_token(p, 636))  // token='except'
             &&
             (_literal = _PyPegen_expect_token(p, 16))  // token='*'
             &&
@@ -22172,7 +22292,7 @@ invalid_finally_stmt_rule(Parser *p)
         Token * a;
         Token * newline_var;
         if (
-            (a = _PyPegen_expect_token(p, 630))  // token='finally'
+            (a = _PyPegen_expect_token(p, 632))  // token='finally'
             &&
             (_literal = _PyPegen_expect_token(p, 11))  // token=':'
             &&
@@ -22229,7 +22349,7 @@ invalid_except_stmt_indent_rule(Parser *p)
         expr_ty expression_var;
         Token * newline_var;
         if (
-            (a = _PyPegen_expect_token(p, 634))  // token='except'
+            (a = _PyPegen_expect_token(p, 636))  // token='except'
             &&
             (expression_var = expression_rule(p))  // expression
             &&
@@ -22265,7 +22385,7 @@ invalid_except_stmt_indent_rule(Parser *p)
         Token * a;
         Token * newline_var;
         if (
-            (a = _PyPegen_expect_token(p, 634))  // token='except'
+            (a = _PyPegen_expect_token(p, 636))  // token='except'
             &&
             (_literal = _PyPegen_expect_token(p, 11))  // token=':'
             &&
@@ -22322,7 +22442,7 @@ invalid_except_star_stmt_indent_rule(Parser *p)
         expr_ty expression_var;
         Token * newline_var;
         if (
-            (a = _PyPegen_expect_token(p, 634))  // token='except'
+            (a = _PyPegen_expect_token(p, 636))  // token='except'
             &&
             (_literal = _PyPegen_expect_token(p, 16))  // token='*'
             &&
@@ -22564,7 +22684,7 @@ invalid_as_pattern_rule(Parser *p)
         if (
             (or_pattern_var = or_pattern_rule(p))  // or_pattern
             &&
-            (_keyword = _PyPegen_expect_token(p, 637))  // token='as'
+            (_keyword = _PyPegen_expect_token(p, 639))  // token='as'
             &&
             (a = _PyPegen_expect_soft_keyword(p, "_"))  // soft_keyword='"_"'
         )
@@ -22594,7 +22714,7 @@ invalid_as_pattern_rule(Parser *p)
         if (
             (or_pattern_var = or_pattern_rule(p))  // or_pattern
             &&
-            (_keyword = _PyPegen_expect_token(p, 637))  // token='as'
+            (_keyword = _PyPegen_expect_token(p, 639))  // token='as'
             &&
             _PyPegen_lookahead_with_name(0, _PyPegen_name_token, p)
             &&
@@ -22751,7 +22871,7 @@ invalid_if_stmt_rule(Parser *p)
         expr_ty named_expression_var;
         Token * newline_var;
         if (
-            (_keyword = _PyPegen_expect_token(p, 639))  // token='if'
+            (_keyword = _PyPegen_expect_token(p, 641))  // token='if'
             &&
             (named_expression_var = named_expression_rule(p))  // named_expression
             &&
@@ -22782,7 +22902,7 @@ invalid_if_stmt_rule(Parser *p)
         expr_ty a_1;
         Token * newline_var;
         if (
-            (a = _PyPegen_expect_token(p, 639))  // token='if'
+            (a = _PyPegen_expect_token(p, 641))  // token='if'
             &&
             (a_1 = named_expression_rule(p))  // named_expression
             &&
@@ -22838,7 +22958,7 @@ invalid_elif_stmt_rule(Parser *p)
         expr_ty named_expression_var;
         Token * newline_var;
         if (
-            (_keyword = _PyPegen_expect_token(p, 641))  // token='elif'
+            (_keyword = _PyPegen_expect_token(p, 643))  // token='elif'
             &&
             (named_expression_var = named_expression_rule(p))  // named_expression
             &&
@@ -22869,7 +22989,7 @@ invalid_elif_stmt_rule(Parser *p)
         expr_ty named_expression_var;
         Token * newline_var;
         if (
-            (a = _PyPegen_expect_token(p, 641))  // token='elif'
+            (a = _PyPegen_expect_token(p, 643))  // token='elif'
             &&
             (named_expression_var = named_expression_rule(p))  // named_expression
             &&
@@ -22923,7 +23043,7 @@ invalid_else_stmt_rule(Parser *p)
         Token * a;
         Token * newline_var;
         if (
-            (a = _PyPegen_expect_token(p, 642))  // token='else'
+            (a = _PyPegen_expect_token(p, 644))  // token='else'
             &&
             (_literal = _PyPegen_expect_token(p, 11))  // token=':'
             &&
@@ -22977,7 +23097,7 @@ invalid_while_stmt_rule(Parser *p)
         expr_ty named_expression_var;
         Token * newline_var;
         if (
-            (_keyword = _PyPegen_expect_token(p, 644))  // token='while'
+            (_keyword = _PyPegen_expect_token(p, 646))  // token='while'
             &&
             (named_expression_var = named_expression_rule(p))  // named_expression
             &&
@@ -23008,7 +23128,7 @@ invalid_while_stmt_rule(Parser *p)
         expr_ty named_expression_var;
         Token * newline_var;
         if (
-            (a = _PyPegen_expect_token(p, 644))  // token='while'
+            (a = _PyPegen_expect_token(p, 646))  // token='while'
             &&
             (named_expression_var = named_expression_rule(p))  // named_expression
             &&
@@ -23038,6 +23158,93 @@ invalid_while_stmt_rule(Parser *p)
     return _res;
 }
 
+// invalid_until_stmt:
+//     | 'until' named_expression NEWLINE
+//     | 'until' named_expression ':' NEWLINE !INDENT
+static void *
+invalid_until_stmt_rule(Parser *p)
+{
+    if (p->level++ == MAXSTACK) {
+        p->error_indicator = 1;
+        PyErr_NoMemory();
+    }
+    if (p->error_indicator) {
+        p->level--;
+        return NULL;
+    }
+    void * _res = NULL;
+    int _mark = p->mark;
+    { // 'until' named_expression NEWLINE
+        if (p->error_indicator) {
+            p->level--;
+            return NULL;
+        }
+        D(fprintf(stderr, "%*c> invalid_until_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'until' named_expression NEWLINE"));
+        Token * _keyword;
+        expr_ty named_expression_var;
+        Token * newline_var;
+        if (
+            (_keyword = _PyPegen_expect_token(p, 648))  // token='until'
+            &&
+            (named_expression_var = named_expression_rule(p))  // named_expression
+            &&
+            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
+        )
+        {
+            D(fprintf(stderr, "%*c+ invalid_until_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'until' named_expression NEWLINE"));
+            _res = RAISE_SYNTAX_ERROR ( "expected ':'" );
+            if (_res == NULL && PyErr_Occurred()) {
+                p->error_indicator = 1;
+                p->level--;
+                return NULL;
+            }
+            goto done;
+        }
+        p->mark = _mark;
+        D(fprintf(stderr, "%*c%s invalid_until_stmt[%d-%d]: %s failed!\n", p->level, ' ',
+                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'until' named_expression NEWLINE"));
+    }
+    { // 'until' named_expression ':' NEWLINE !INDENT
+        if (p->error_indicator) {
+            p->level--;
+            return NULL;
+        }
+        D(fprintf(stderr, "%*c> invalid_until_stmt[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'until' named_expression ':' NEWLINE !INDENT"));
+        Token * _literal;
+        Token * a;
+        expr_ty named_expression_var;
+        Token * newline_var;
+        if (
+            (a = _PyPegen_expect_token(p, 648))  // token='until'
+            &&
+            (named_expression_var = named_expression_rule(p))  // named_expression
+            &&
+            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
+            &&
+            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
+            &&
+            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)  // token=INDENT
+        )
+        {
+            D(fprintf(stderr, "%*c+ invalid_until_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'until' named_expression ':' NEWLINE !INDENT"));
+            _res = RAISE_INDENTATION_ERROR ( "expected an indented block after 'until' statement on line %d" , a -> lineno );
+            if (_res == NULL && PyErr_Occurred()) {
+                p->error_indicator = 1;
+                p->level--;
+                return NULL;
+            }
+            goto done;
+        }
+        p->mark = _mark;
+        D(fprintf(stderr, "%*c%s invalid_until_stmt[%d-%d]: %s failed!\n", p->level, ' ',
+                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "'until' named_expression ':' NEWLINE !INDENT"));
+    }
+    _res = NULL;
+  done:
+    p->level--;
+    return _res;
+}
+
 // invalid_for_stmt:
 //     | ASYNC? 'for' star_targets 'in' star_expressions NEWLINE
 //     | ASYNC? 'for' star_targets 'in' star_expressions ':' NEWLINE !INDENT
@@ -23070,11 +23277,11 @@ invalid_for_stmt_rule(Parser *p)
         if (
             (_opt_var = _PyPegen_expect_token(p, ASYNC), !p->error_indicator)  // ASYNC?
             &&
-            (_keyword = _PyPegen_expect_token(p, 647))  // token='for'
+            (_keyword = _PyPegen_expect_token(p, 651))  // token='for'
             &&
             (star_targets_var = star_targets_rule(p))  // star_targets
             &&
-            (_keyword_1 = _PyPegen_expect_token(p, 648))  // token='in'
+            (_keyword_1 = _PyPegen_expect_token(p, 652))  // token='in'
             &&
             (star_expressions_var = star_expressions_rule(p))  // star_expressions
             &&
@@ -23111,11 +23318,11 @@ invalid_for_stmt_rule(Parser *p)
         if (
             (_opt_var = _PyPegen_expect_token(p, ASYNC), !p->error_indicator)  // ASYNC?
             &&
-            (a = _PyPegen_expect_token(p, 647))  // token='for'
+            (a = _PyPegen_expect_token(p, 651))  // token='for'
             &&
             (star_targets_var = star_targets_rule(p))  // star_targets
             &&
-            (_keyword = _PyPegen_expect_token(p, 648))  // token='in'
+            (_keyword = _PyPegen_expect_token(p, 652))  // token='in'
             &&
             (star_expressions_var = star_expressions_rule(p))  // star_expressions
             &&
@@ -23181,7 +23388,7 @@ invalid_def_raw_rule(Parser *p)
         if (
             (_opt_var = _PyPegen_expect_token(p, ASYNC), !p->error_indicator)  // ASYNC?
             &&
-            (a = _PyPegen_expect_token(p, 649))  // token='def'
+            (a = _PyPegen_expect_token(p, 653))  // token='def'
             &&
             (name_var = _PyPegen_name_token(p))  // NAME
             &&
@@ -23247,7 +23454,7 @@ invalid_class_def_raw_rule(Parser *p)
         expr_ty name_var;
         Token * newline_var;
         if (
-            (_keyword = _PyPegen_expect_token(p, 651))  // token='class'
+            (_keyword = _PyPegen_expect_token(p, 655))  // token='class'
             &&
             (name_var = _PyPegen_name_token(p))  // NAME
             &&
@@ -23282,7 +23489,7 @@ invalid_class_def_raw_rule(Parser *p)
         expr_ty name_var;
         Token * newline_var;
         if (
-            (a = _PyPegen_expect_token(p, 651))  // token='class'
+            (a = _PyPegen_expect_token(p, 655))  // token='class'
             &&
             (name_var = _PyPegen_name_token(p))  // NAME
             &&
@@ -23885,7 +24092,7 @@ _tmp_6_rule(Parser *p)
         D(fprintf(stderr, "%*c> _tmp_6[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'import'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 531))  // token='import'
+            (_keyword = _PyPegen_expect_token(p, 532))  // token='import'
         )
         {
             D(fprintf(stderr, "%*c+ _tmp_6[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'import'"));
@@ -23904,7 +24111,7 @@ _tmp_6_rule(Parser *p)
         D(fprintf(stderr, "%*c> _tmp_6[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'from'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 572))  // token='from'
+            (_keyword = _PyPegen_expect_token(p, 574))  // token='from'
         )
         {
             D(fprintf(stderr, "%*c+ _tmp_6[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'from'"));
@@ -23943,7 +24150,7 @@ _tmp_7_rule(Parser *p)
         D(fprintf(stderr, "%*c> _tmp_7[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'def'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 649))  // token='def'
+            (_keyword = _PyPegen_expect_token(p, 653))  // token='def'
         )
         {
             D(fprintf(stderr, "%*c+ _tmp_7[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'def'"));
@@ -24020,7 +24227,7 @@ _tmp_8_rule(Parser *p)
         D(fprintf(stderr, "%*c> _tmp_8[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'class'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 651))  // token='class'
+            (_keyword = _PyPegen_expect_token(p, 655))  // token='class'
         )
         {
             D(fprintf(stderr, "%*c+ _tmp_8[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'class'"));
@@ -24078,7 +24285,7 @@ _tmp_9_rule(Parser *p)
         D(fprintf(stderr, "%*c> _tmp_9[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'with'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 612))  // token='with'
+            (_keyword = _PyPegen_expect_token(p, 614))  // token='with'
         )
         {
             D(fprintf(stderr, "%*c+ _tmp_9[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'with'"));
@@ -24136,7 +24343,7 @@ _tmp_10_rule(Parser *p)
         D(fprintf(stderr, "%*c> _tmp_10[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'for'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 647))  // token='for'
+            (_keyword = _PyPegen_expect_token(p, 651))  // token='for'
         )
         {
             D(fprintf(stderr, "%*c+ _tmp_10[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'for'"));
@@ -24547,7 +24754,7 @@ _tmp_17_rule(Parser *p)
         Token * _keyword;
         expr_ty z;
         if (
-            (_keyword = _PyPegen_expect_token(p, 572))  // token='from'
+            (_keyword = _PyPegen_expect_token(p, 574))  // token='from'
             &&
             (z = expression_rule(p))  // expression
         )
@@ -25197,7 +25404,7 @@ _tmp_28_rule(Parser *p)
         Token * _keyword;
         expr_ty z;
         if (
-            (_keyword = _PyPegen_expect_token(p, 637))  // token='as'
+            (_keyword = _PyPegen_expect_token(p, 639))  // token='as'
             &&
             (z = _PyPegen_name_token(p))  // NAME
         )
@@ -25363,7 +25570,7 @@ _tmp_31_rule(Parser *p)
         Token * _keyword;
         expr_ty z;
         if (
-            (_keyword = _PyPegen_expect_token(p, 637))  // token='as'
+            (_keyword = _PyPegen_expect_token(p, 639))  // token='as'
             &&
             (z = _PyPegen_name_token(p))  // NAME
         )
@@ -27381,7 +27588,7 @@ _tmp_62_rule(Parser *p)
         Token * _keyword;
         expr_ty z;
         if (
-            (_keyword = _PyPegen_expect_token(p, 637))  // token='as'
+            (_keyword = _PyPegen_expect_token(p, 639))  // token='as'
             &&
             (z = _PyPegen_name_token(p))  // NAME
         )
@@ -27428,7 +27635,7 @@ _tmp_63_rule(Parser *p)
         Token * _keyword;
         expr_ty z;
         if (
-            (_keyword = _PyPegen_expect_token(p, 637))  // token='as'
+            (_keyword = _PyPegen_expect_token(p, 639))  // token='as'
             &&
             (z = _PyPegen_name_token(p))  // NAME
         )
@@ -32593,7 +32800,7 @@ _tmp_145_rule(Parser *p)
         D(fprintf(stderr, "%*c> _tmp_145[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'True'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 600))  // token='True'
+            (_keyword = _PyPegen_expect_token(p, 602))  // token='True'
         )
         {
             D(fprintf(stderr, "%*c+ _tmp_145[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'True'"));
@@ -32612,7 +32819,7 @@ _tmp_145_rule(Parser *p)
         D(fprintf(stderr, "%*c> _tmp_145[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'False'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 602))  // token='False'
+            (_keyword = _PyPegen_expect_token(p, 604))  // token='False'
         )
         {
             D(fprintf(stderr, "%*c+ _tmp_145[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'False'"));
@@ -32631,7 +32838,7 @@ _tmp_145_rule(Parser *p)
         D(fprintf(stderr, "%*c> _tmp_145[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'None'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 601))  // token='None'
+            (_keyword = _PyPegen_expect_token(p, 603))  // token='None'
         )
         {
             D(fprintf(stderr, "%*c+ _tmp_145[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'None'"));
@@ -32773,7 +32980,7 @@ _tmp_148_rule(Parser *p)
         D(fprintf(stderr, "%*c> _tmp_148[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'else'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 642))  // token='else'
+            (_keyword = _PyPegen_expect_token(p, 644))  // token='else'
         )
         {
             D(fprintf(stderr, "%*c+ _tmp_148[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'else'"));
@@ -32946,7 +33153,7 @@ _tmp_150_rule(Parser *p)
         D(fprintf(stderr, "%*c> _tmp_150[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'True'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 600))  // token='True'
+            (_keyword = _PyPegen_expect_token(p, 602))  // token='True'
         )
         {
             D(fprintf(stderr, "%*c+ _tmp_150[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'True'"));
@@ -32965,7 +33172,7 @@ _tmp_150_rule(Parser *p)
         D(fprintf(stderr, "%*c> _tmp_150[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'None'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 601))  // token='None'
+            (_keyword = _PyPegen_expect_token(p, 603))  // token='None'
         )
         {
             D(fprintf(stderr, "%*c+ _tmp_150[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'None'"));
@@ -32984,7 +33191,7 @@ _tmp_150_rule(Parser *p)
         D(fprintf(stderr, "%*c> _tmp_150[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'False'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 602))  // token='False'
+            (_keyword = _PyPegen_expect_token(p, 604))  // token='False'
         )
         {
             D(fprintf(stderr, "%*c+ _tmp_150[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'False'"));
@@ -36303,7 +36510,7 @@ _tmp_202_rule(Parser *p)
         D(fprintf(stderr, "%*c> _tmp_202[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'except'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 634))  // token='except'
+            (_keyword = _PyPegen_expect_token(p, 636))  // token='except'
         )
         {
             D(fprintf(stderr, "%*c+ _tmp_202[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'except'"));
@@ -36322,7 +36529,7 @@ _tmp_202_rule(Parser *p)
         D(fprintf(stderr, "%*c> _tmp_202[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "'finally'"));
         Token * _keyword;
         if (
-            (_keyword = _PyPegen_expect_token(p, 630))  // token='finally'
+            (_keyword = _PyPegen_expect_token(p, 632))  // token='finally'
         )
         {
             D(fprintf(stderr, "%*c+ _tmp_202[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'finally'"));
@@ -36503,7 +36710,7 @@ _tmp_205_rule(Parser *p)
         Token * _keyword;
         expr_ty name_var;
         if (
-            (_keyword = _PyPegen_expect_token(p, 637))  // token='as'
+            (_keyword = _PyPegen_expect_token(p, 639))  // token='as'
             &&
             (name_var = _PyPegen_name_token(p))  // NAME
         )
@@ -36729,7 +36936,7 @@ _tmp_209_rule(Parser *p)
         Token * _keyword;
         expr_ty name_var;
         if (
-            (_keyword = _PyPegen_expect_token(p, 637))  // token='as'
+            (_keyword = _PyPegen_expect_token(p, 639))  // token='as'
             &&
             (name_var = _PyPegen_name_token(p))  // NAME
         )
@@ -36771,7 +36978,7 @@ _tmp_210_rule(Parser *p)
         Token * _keyword;
         expr_ty name_var;
         if (
-            (_keyword = _PyPegen_expect_token(p, 637))  // token='as'
+            (_keyword = _PyPegen_expect_token(p, 639))  // token='as'
             &&
             (name_var = _PyPegen_name_token(p))  // NAME
         )
@@ -36871,7 +37078,7 @@ _tmp_212_rule(Parser *p)
         Token * _keyword;
         expr_ty name_var;
         if (
-            (_keyword = _PyPegen_expect_token(p, 637))  // token='as'
+            (_keyword = _PyPegen_expect_token(p, 639))  // token='as'
             &&
             (name_var = _PyPegen_name_token(p))  // NAME
         )
@@ -36913,7 +37120,7 @@ _tmp_213_rule(Parser *p)
         Token * _keyword;
         expr_ty name_var;
         if (
-            (_keyword = _PyPegen_expect_token(p, 637))  // token='as'
+            (_keyword = _PyPegen_expect_token(p, 639))  // token='as'
             &&
             (name_var = _PyPegen_name_token(p))  // NAME
         )
@@ -37673,7 +37880,7 @@ _tmp_228_rule(Parser *p)
         Token * _keyword;
         expr_ty c;
         if (
-            (_keyword = _PyPegen_expect_token(p, 574))  // token='or'
+            (_keyword = _PyPegen_expect_token(p, 576))  // token='or'
             &&
             (c = conjunction_rule(p))  // conjunction
         )
@@ -37720,7 +37927,7 @@ _tmp_229_rule(Parser *p)
         Token * _keyword;
         expr_ty c;
         if (
-            (_keyword = _PyPegen_expect_token(p, 575))  // token='and'
+            (_keyword = _PyPegen_expect_token(p, 577))  // token='and'
             &&
             (c = inversion_rule(p))  // inversion
         )
@@ -37825,7 +38032,7 @@ _tmp_231_rule(Parser *p)
         Token * _keyword;
         expr_ty z;
         if (
-            (_keyword = _PyPegen_expect_token(p, 639))  // token='if'
+            (_keyword = _PyPegen_expect_token(p, 641))  // token='if'
             &&
             (z = disjunction_rule(p))  // disjunction
         )
@@ -37872,7 +38079,7 @@ _tmp_232_rule(Parser *p)
         Token * _keyword;
         expr_ty z;
         if (
-            (_keyword = _PyPegen_expect_token(p, 639))  // token='if'
+            (_keyword = _PyPegen_expect_token(p, 641))  // token='if'
             &&
             (z = disjunction_rule(p))  // disjunction
         )
@@ -38445,7 +38652,7 @@ _tmp_244_rule(Parser *p)
         Token * _keyword;
         expr_ty name_var;
         if (
-            (_keyword = _PyPegen_expect_token(p, 637))  // token='as'
+            (_keyword = _PyPegen_expect_token(p, 639))  // token='as'
             &&
             (name_var = _PyPegen_name_token(p))  // NAME
         )
@@ -38547,7 +38754,7 @@ _tmp_246_rule(Parser *p)
         Token * _keyword;
         expr_ty star_target_var;
         if (
-            (_keyword = _PyPegen_expect_token(p, 637))  // token='as'
+            (_keyword = _PyPegen_expect_token(p, 639))  // token='as'
             &&
             (star_target_var = star_target_rule(p))  // star_target
         )
@@ -38589,7 +38796,7 @@ _tmp_247_rule(Parser *p)
         Token * _keyword;
         expr_ty star_target_var;
         if (
-            (_keyword = _PyPegen_expect_token(p, 637))  // token='as'
+            (_keyword = _PyPegen_expect_token(p, 639))  // token='as'
             &&
             (star_target_var = star_target_rule(p))  // star_target
         )
@@ -38631,7 +38838,7 @@ _tmp_248_rule(Parser *p)
         Token * _keyword;
         expr_ty star_target_var;
         if (
-            (_keyword = _PyPegen_expect_token(p, 637))  // token='as'
+            (_keyword = _PyPegen_expect_token(p, 639))  // token='as'
             &&
             (star_target_var = star_target_rule(p))  // star_target
         )
@@ -38673,7 +38880,7 @@ _tmp_249_rule(Parser *p)
         Token * _keyword;
         expr_ty star_target_var;
         if (
-            (_keyword = _PyPegen_expect_token(p, 637))  // token='as'
+            (_keyword = _PyPegen_expect_token(p, 639))  // token='as'
             &&
             (star_target_var = star_target_rule(p))  // star_target
         )
diff --git a/Python/Python-ast.c b/Python/Python-ast.c
index 9139f6e54f..db72ce2518 100644
--- a/Python/Python-ast.c
+++ b/Python/Python-ast.c
@@ -156,6 +156,7 @@ void _PyAST_Fini(PyInterpreterState *interp)
     Py_CLEAR(state->USub_singleton);
     Py_CLEAR(state->USub_type);
     Py_CLEAR(state->UnaryOp_type);
+    Py_CLEAR(state->Until_type);
     Py_CLEAR(state->While_type);
     Py_CLEAR(state->With_type);
     Py_CLEAR(state->YieldFrom_type);
@@ -459,6 +460,11 @@ static const char * const While_fields[]={
     "body",
     "orelse",
 };
+static const char * const Until_fields[]={
+    "test",
+    "body",
+    "orelse",
+};
 static const char * const If_fields[]={
     "test",
     "body",
@@ -1141,6 +1147,7 @@ init_types(struct ast_state *state)
         "     | For(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)\n"
         "     | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)\n"
         "     | While(expr test, stmt* body, stmt* orelse)\n"
+        "     | Until(expr test, stmt* body, stmt* orelse)\n"
         "     | If(expr test, stmt* body, stmt* orelse)\n"
         "     | With(withitem* items, stmt* body, string? type_comment)\n"
         "     | AsyncWith(withitem* items, stmt* body, string? type_comment)\n"
@@ -1232,6 +1239,10 @@ init_types(struct ast_state *state)
                                   While_fields, 3,
         "While(expr test, stmt* body, stmt* orelse)");
     if (!state->While_type) return 0;
+    state->Until_type = make_type(state, "Until", state->stmt_type,
+                                  Until_fields, 3,
+        "Until(expr test, stmt* body, stmt* orelse)");
+    if (!state->Until_type) return 0;
     state->If_type = make_type(state, "If", state->stmt_type, If_fields, 3,
         "If(expr test, stmt* body, stmt* orelse)");
     if (!state->If_type) return 0;
@@ -2264,6 +2275,31 @@ _PyAST_While(expr_ty test, asdl_stmt_seq * body, asdl_stmt_seq * orelse, int
     return p;
 }
 
+stmt_ty
+_PyAST_Until(expr_ty test, asdl_stmt_seq * body, asdl_stmt_seq * orelse, int
+             lineno, int col_offset, int end_lineno, int end_col_offset,
+             PyArena *arena)
+{
+    stmt_ty p;
+    if (!test) {
+        PyErr_SetString(PyExc_ValueError,
+                        "field 'test' is required for Until");
+        return NULL;
+    }
+    p = (stmt_ty)_PyArena_Malloc(arena, sizeof(*p));
+    if (!p)
+        return NULL;
+    p->kind = Until_kind;
+    p->v.Until.test = test;
+    p->v.Until.body = body;
+    p->v.Until.orelse = orelse;
+    p->lineno = lineno;
+    p->col_offset = col_offset;
+    p->end_lineno = end_lineno;
+    p->end_col_offset = end_col_offset;
+    return p;
+}
+
 stmt_ty
 _PyAST_If(expr_ty test, asdl_stmt_seq * body, asdl_stmt_seq * orelse, int
           lineno, int col_offset, int end_lineno, int end_col_offset, PyArena
@@ -3973,6 +4009,26 @@ ast2obj_stmt(struct ast_state *state, void* _o)
             goto failed;
         Py_DECREF(value);
         break;
+    case Until_kind:
+        tp = (PyTypeObject *)state->Until_type;
+        result = PyType_GenericNew(tp, NULL, NULL);
+        if (!result) goto failed;
+        value = ast2obj_expr(state, o->v.Until.test);
+        if (!value) goto failed;
+        if (PyObject_SetAttr(result, state->test, value) == -1)
+            goto failed;
+        Py_DECREF(value);
+        value = ast2obj_list(state, (asdl_seq*)o->v.Until.body, ast2obj_stmt);
+        if (!value) goto failed;
+        if (PyObject_SetAttr(result, state->body, value) == -1)
+            goto failed;
+        Py_DECREF(value);
+        value = ast2obj_list(state, (asdl_seq*)o->v.Until.orelse, ast2obj_stmt);
+        if (!value) goto failed;
+        if (PyObject_SetAttr(result, state->orelse, value) == -1)
+            goto failed;
+        Py_DECREF(value);
+        break;
     case If_kind:
         tp = (PyTypeObject *)state->If_type;
         result = PyType_GenericNew(tp, NULL, NULL);
@@ -7019,6 +7075,112 @@ obj2ast_stmt(struct ast_state *state, PyObject* obj, stmt_ty* out, PyArena*
         if (*out == NULL) goto failed;
         return 0;
     }
+    tp = state->Until_type;
+    isinstance = PyObject_IsInstance(obj, tp);
+    if (isinstance == -1) {
+        return 1;
+    }
+    if (isinstance) {
+        expr_ty test;
+        asdl_stmt_seq* body;
+        asdl_stmt_seq* orelse;
+
+        if (_PyObject_LookupAttr(obj, state->test, &tmp) < 0) {
+            return 1;
+        }
+        if (tmp == NULL) {
+            PyErr_SetString(PyExc_TypeError, "required field \"test\" missing from Until");
+            return 1;
+        }
+        else {
+            int res;
+            if (_Py_EnterRecursiveCall(" while traversing 'Until' node")) {
+                goto failed;
+            }
+            res = obj2ast_expr(state, tmp, &test, arena);
+            _Py_LeaveRecursiveCall();
+            if (res != 0) goto failed;
+            Py_CLEAR(tmp);
+        }
+        if (_PyObject_LookupAttr(obj, state->body, &tmp) < 0) {
+            return 1;
+        }
+        if (tmp == NULL) {
+            PyErr_SetString(PyExc_TypeError, "required field \"body\" missing from Until");
+            return 1;
+        }
+        else {
+            int res;
+            Py_ssize_t len;
+            Py_ssize_t i;
+            if (!PyList_Check(tmp)) {
+                PyErr_Format(PyExc_TypeError, "Until field \"body\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
+                goto failed;
+            }
+            len = PyList_GET_SIZE(tmp);
+            body = _Py_asdl_stmt_seq_new(len, arena);
+            if (body == NULL) goto failed;
+            for (i = 0; i < len; i++) {
+                stmt_ty val;
+                PyObject *tmp2 = PyList_GET_ITEM(tmp, i);
+                Py_INCREF(tmp2);
+                if (_Py_EnterRecursiveCall(" while traversing 'Until' node")) {
+                    goto failed;
+                }
+                res = obj2ast_stmt(state, tmp2, &val, arena);
+                _Py_LeaveRecursiveCall();
+                Py_DECREF(tmp2);
+                if (res != 0) goto failed;
+                if (len != PyList_GET_SIZE(tmp)) {
+                    PyErr_SetString(PyExc_RuntimeError, "Until field \"body\" changed size during iteration");
+                    goto failed;
+                }
+                asdl_seq_SET(body, i, val);
+            }
+            Py_CLEAR(tmp);
+        }
+        if (_PyObject_LookupAttr(obj, state->orelse, &tmp) < 0) {
+            return 1;
+        }
+        if (tmp == NULL) {
+            PyErr_SetString(PyExc_TypeError, "required field \"orelse\" missing from Until");
+            return 1;
+        }
+        else {
+            int res;
+            Py_ssize_t len;
+            Py_ssize_t i;
+            if (!PyList_Check(tmp)) {
+                PyErr_Format(PyExc_TypeError, "Until field \"orelse\" must be a list, not a %.200s", _PyType_Name(Py_TYPE(tmp)));
+                goto failed;
+            }
+            len = PyList_GET_SIZE(tmp);
+            orelse = _Py_asdl_stmt_seq_new(len, arena);
+            if (orelse == NULL) goto failed;
+            for (i = 0; i < len; i++) {
+                stmt_ty val;
+                PyObject *tmp2 = PyList_GET_ITEM(tmp, i);
+                Py_INCREF(tmp2);
+                if (_Py_EnterRecursiveCall(" while traversing 'Until' node")) {
+                    goto failed;
+                }
+                res = obj2ast_stmt(state, tmp2, &val, arena);
+                _Py_LeaveRecursiveCall();
+                Py_DECREF(tmp2);
+                if (res != 0) goto failed;
+                if (len != PyList_GET_SIZE(tmp)) {
+                    PyErr_SetString(PyExc_RuntimeError, "Until field \"orelse\" changed size during iteration");
+                    goto failed;
+                }
+                asdl_seq_SET(orelse, i, val);
+            }
+            Py_CLEAR(tmp);
+        }
+        *out = _PyAST_Until(test, body, orelse, lineno, col_offset, end_lineno,
+                            end_col_offset, arena);
+        if (*out == NULL) goto failed;
+        return 0;
+    }
     tp = state->If_type;
     isinstance = PyObject_IsInstance(obj, tp);
     if (isinstance == -1) {
@@ -11980,6 +12142,9 @@ astmodule_exec(PyObject *m)
     if (PyModule_AddObjectRef(m, "While", state->While_type) < 0) {
         return -1;
     }
+    if (PyModule_AddObjectRef(m, "Until", state->Until_type) < 0) {
+        return -1;
+    }
     if (PyModule_AddObjectRef(m, "If", state->If_type) < 0) {
         return -1;
     }
diff --git a/Python/ast.c b/Python/ast.c
index 95179cb702..1296a1997c 100644
--- a/Python/ast.c
+++ b/Python/ast.c
@@ -780,6 +780,11 @@ validate_stmt(struct validator *state, stmt_ty stmt)
             validate_body(state, stmt->v.While.body, "While") &&
             validate_stmts(state, stmt->v.While.orelse);
         break;
+    case Until_kind:
+        ret = validate_expr(state, stmt->v.Until.test, Load) &&
+            validate_body(state, stmt->v.Until.body, "Until") &&
+            validate_stmts(state, stmt->v.Until.orelse);
+        break;
     case If_kind:
         ret = validate_expr(state, stmt->v.If.test, Load) &&
             validate_body(state, stmt->v.If.body, "If") &&
diff --git a/Python/ast_opt.c b/Python/ast_opt.c
index 77ed29d0cd..e6e29d8c2d 100644
--- a/Python/ast_opt.c
+++ b/Python/ast_opt.c
@@ -935,6 +935,11 @@ astfold_stmt(stmt_ty node_, PyArena *ctx_, _PyASTOptimizeState *state)
         CALL_SEQ(astfold_stmt, stmt, node_->v.While.body);
         CALL_SEQ(astfold_stmt, stmt, node_->v.While.orelse);
         break;
+    case Until_kind:
+        CALL(astfold_expr, expr_ty, node_->v.Until.test);
+        CALL_SEQ(astfold_stmt, stmt, node_->v.Until.body);
+        CALL_SEQ(astfold_stmt, stmt, node_->v.Until.orelse);
+        break;
     case If_kind:
         CALL(astfold_expr, expr_ty, node_->v.If.test);
         CALL_SEQ(astfold_stmt, stmt, node_->v.If.body);
diff --git a/Python/compile.c b/Python/compile.c
index 558df3fca6..5186da2af4 100644
--- a/Python/compile.c
+++ b/Python/compile.c
@@ -273,7 +273,7 @@ compiler IR.
 
 enum fblocktype { WHILE_LOOP, FOR_LOOP, TRY_EXCEPT, FINALLY_TRY, FINALLY_END,
                   WITH, ASYNC_WITH, HANDLER_CLEANUP, POP_VALUE, EXCEPTION_HANDLER,
-                  EXCEPTION_GROUP_HANDLER, ASYNC_COMPREHENSION_GENERATOR };
+                  EXCEPTION_GROUP_HANDLER, ASYNC_COMPREHENSION_GENERATOR, UNTIL_LOOP };
 
 struct fblockinfo {
     enum fblocktype fb_type;
@@ -1875,6 +1875,10 @@ find_ann(asdl_stmt_seq *stmts)
             res = find_ann(st->v.While.body) ||
                   find_ann(st->v.While.orelse);
             break;
+        case Until_kind:
+            res = find_ann(st->v.Until.body) ||
+                  find_ann(st->v.Until.orelse);
+            break;
         case If_kind:
             res = find_ann(st->v.If.body) ||
                   find_ann(st->v.If.orelse);
@@ -2015,6 +2019,7 @@ compiler_unwind_fblock(struct compiler *c, struct fblockinfo *info,
 {
     switch (info->fb_type) {
         case WHILE_LOOP:
+        case UNTIL_LOOP:
         case EXCEPTION_HANDLER:
         case EXCEPTION_GROUP_HANDLER:
         case ASYNC_COMPREHENSION_GENERATOR:
@@ -2122,7 +2127,7 @@ compiler_unwind_fblock_stack(struct compiler *c, int preserve_tos, struct fblock
         return compiler_error(
             c, "'break', 'continue' and 'return' cannot appear in an except* block");
     }
-    if (loop != NULL && (top->fb_type == WHILE_LOOP || top->fb_type == FOR_LOOP)) {
+    if (loop != NULL && (top->fb_type == WHILE_LOOP || top->fb_type == FOR_LOOP || top->fb_type == UNTIL_LOOP)) {
         *loop = top;
         return 1;
     }
@@ -3228,6 +3233,39 @@ compiler_while(struct compiler *c, stmt_ty s)
     return 1;
 }
 
+static int
+compiler_until(struct compiler *c, stmt_ty s)
+{
+    basicblock *loop, *body, *end, *anchor = NULL;
+    loop = compiler_new_block(c);
+    body = compiler_new_block(c);
+    anchor = compiler_new_block(c);
+    end = compiler_new_block(c);
+    if (loop == NULL || body == NULL || anchor == NULL || end == NULL) {
+        return 0;
+    }
+    compiler_use_next_block(c, loop);
+    if (!compiler_push_fblock(c, WHILE_LOOP, loop, end, NULL)) {
+        return 0;
+    }
+    if (!compiler_jump_if(c, s->v.While.test, end, 1)) {
+        return 0;
+    }
+
+    compiler_use_next_block(c, body);
+    VISIT_SEQ(c, stmt, s->v.While.body);
+    SET_LOC(c, s);
+    if (!compiler_jump_if(c, s->v.While.test, body, 0)) {
+        return 0;
+    }
+
+    compiler_pop_fblock(c, WHILE_LOOP, loop);
+
+    compiler_use_next_block(c, end);
+
+    return 1;
+}
+
 static int
 compiler_return(struct compiler *c, stmt_ty s)
 {
@@ -4114,6 +4152,8 @@ compiler_visit_stmt(struct compiler *c, stmt_ty s)
         return compiler_for(c, s);
     case While_kind:
         return compiler_while(c, s);
+    case Until_kind:
+        return compiler_until(c, s);
     case If_kind:
         return compiler_if(c, s);
     case Match_kind:
diff --git a/Python/symtable.c b/Python/symtable.c
index 0b259b08b6..f2eb3a5ab3 100644
--- a/Python/symtable.c
+++ b/Python/symtable.c
@@ -1308,6 +1308,12 @@ symtable_visit_stmt(struct symtable *st, stmt_ty s)
         if (s->v.While.orelse)
             VISIT_SEQ(st, stmt, s->v.While.orelse);
         break;
+    case Until_kind:
+        VISIT(st, expr, s->v.Until.test);
+        VISIT_SEQ(st, stmt, s->v.Until.body);
+        if (s->v.Until.orelse)
+            VISIT_SEQ(st, stmt, s->v.Until.orelse);
+        break;
     case If_kind:
         /* XXX if 0: and lookup_yield() hacks */
         VISIT(st, expr, s->v.If.test);
